{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"lume-epics","text":"<p>LUME-EPICS is a dedicated API for serving LUME model variables with EPICS.</p>"},{"location":"#model-development","title":"Model Development","text":"<p>The LUME-EPICS server must be instantiated with a user defined class holding all methods necessary for model execution and the  input and output variables associated with the model. For the purpose of example, we consider a model that accepts two float inputs and returns a value sampled between the two inputs.</p> <p>Our model expressed as a function:</p> <pre><code>import numpy as np\n\ndef model_fn(input_1, input_2):\n    return np.random.uniform(input_1, input_2)\n</code></pre>"},{"location":"#defining-input-and-output-variables","title":"Defining input and output variables","text":"<p>Model input and output variables are represented by lume-model variables. These variables enforce the minimal data requirements necessary for serving EPICS process variables associated with an online model. LUME-model defines two variable types: scalar and image. Each type has both an associated input and output class. Scalar variables hold float values, arrays variables and image variables hold arrays.</p> <p>In order to appropriately interface with the EPICS server, scalar input variables must be assigned a range and default. When started, the server uses these defaults to execute the model and serve output variables based on the default execution. The range limits correspond the the low and high limits for EPICS graphics displays. During model execution, the current value of the variable is stored using the <code>value</code> attribute.</p> <p>For our model, we must define two scalar input variables and one scalar output variable:</p> <pre><code>from lume_model.variables import ScalarInputVariable, ScalarOutputVariable\n\ninput_1 = ScalarInputVariable(\n    name=\"input_1\",\n    default=1.0,\n    range=[0, 256]\n)\n\ninput_2 = ScalarInputVariable(\n    name=\"input_2\",\n    default=2.0,\n    range=[0, 256]\n)\n\noutput = ScalarOutputVariable(name=\"output\")\n</code></pre>"},{"location":"#defining-the-model","title":"Defining the model","text":"<p>LUME-model includes a BaseModel base class to enforce the defined class's compatability with the lume-epics server. The primary function of this base class is to force the implementation of an evaluate method. This method must accept a list of <code>lume-model</code> input variables, execute the model, and return a list of <code>lume-model</code> output variables. Input variables and output variables must be defined as class attributes. They may be defined directly as class attributes or assigned in init.</p> <p>For our model, we will construct a class that accepts and stores our input and output variables on initialization. Then, we implement an <code>evaluate</code> method that accepts an updated list of input variables, executes the model, and updates the output variable value appropriately. Place the following code in a file named <code>server.py</code>.</p> <pre><code>from lume_epics.model import BaseModel\nimport numpy as np\n\nclass ExampleModel(BaseModel):\n    def __init__(self, input_variables = [], output_variables = []):\n        self.input_variables = input_variables\n        self.output_variables = output_variables\n\n    def evaluate(self, input_variables):\n        self.input_variables = {input_variable.name: input_variable for input_variable in input_variables}\n        self.output_variables[\"output\"].value = np.random.uniform(\n            self.input_variables[\"input_1\"].value, self.input_variables[\"input_2\"].value\n        )\n        return list(self.output_variables.values()\n</code></pre>"},{"location":"#setting-up-the-server","title":"Setting up the server","text":"<p>We can now use the EPICS server to serve our model. The EPICS server requires an instantiated model with <code>input_variables</code> and <code>output_variables</code> defined as attributes and a YAML configuration file for pvname assignments and protocol, see EPICS. Once instantiated, the server is run using the <code>Server.start()</code> method, which has an optional monitor keyword argument, <code>monitor</code>, that controls thread execution. When <code>monitor=True</code>, the server is run in the main thread and may be stopped using keyboard interrupt (<code>Ctr+C</code>). If using <code>monitor=False</code>, the server can be stopped manually using the <code>Server.stop()</code> method.</p> <p>The input variables and output variables must be passed in the <code>model_kwargs</code> keyword argument because the model class accepts them in its <code>__init__</code> method. Arbitrary data may also be passed to the model with this approach.</p> <p>The same variables used for instantiating the server must be used for building the client tooling. Variables are described in a YAML file with the following format:</p> <pre><code>input_variables:\n  input1:\n      name: input1\n      type: scalar\n      default: 1\n      range: [0, 256]\n\n  input2:\n      name: input2\n      type: scalar\n      default: 2.0\n      range: [0, 256]\n\noutput_variables:\n  output1:\n    name: output1\n    type: scalar\n</code></pre> <p>Another YAML file must describe our EPICS configuration. The variable <code>input1</code> will be served using Channel access using the pvname <code>test:input1</code>. The variables <code>input2</code> and <code>output1</code> will be served using pvAccess.</p> <pre><code>input_variables:\n  input1:\n    pvname: test:input1\n    protocol: ca\n\n  input2:\n    pvname: test:input2\n    protocol: pva\n\noutput_variables:\n  output1:\n    pvname: test:output1\n    protocol: pva\n</code></pre> <p>These are then loaded during server construction:</p> <pre><code>from lume_epics.epics_server import Server\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\nfrom lume_epics.model import BaseModel\nimport numpy as np\n\n\nclass ExampleModel(BaseModel):\n    def __init__(self, input_variables = [], output_variables = []):\n        self.input_variables = input_variables\n        self.output_variables = output_variables\n\n    def evaluate(self, input_variables):\n        self.input_variables = {input_variable.name: input_variable for input_variable in input_variables}\n        self.output_variables[\"output\"].value = np.random.uniform(\n            self.input_variables[\"input_1\"].value, self.input_variables[\"input_2\"].value\n        )\n        return list(self.output_variables.values()\n\n# Server must run in main\nif __name__ == \"__main__\":\n        with open(\"my_variables.yml\", \"r\") as f:\n        input_variables, output_variables = variables_from_yaml(f)\n\n    with open(\"my_epics_config.yml\", \"r\") as f:\n        epics_config = config_from_yaml(f)\n\n    # pass the input + output variable to initialize the classs\n    model_kwargs = {\n        \"input_variables\": input_variables,\n        \"output_variables\": output_variables\n    }\n\n    server = Server(\n        ExampleModel,\n        epics_config,\n        model_kwargs=model_kwargs\n    )\n    # monitor = False does not loop in main thread\n    server.start(monitor=True)\n</code></pre>"},{"location":"#setting-up-the-client","title":"Setting up the client","text":"<p>A number of EPICS compatable widgets are included in <code>lume-epics</code>. Each widget accepts a controller used to monitor EPICS process variables. The controller is then used by a widget-specific monitor, which is responsible for formatting outputs of EPICS values into formats usable by the widget. There are currently slider, value table, image, and striptool widgets; however, more widgets could be configured using the base monitor and controller classes included in <code>lume_epics/client/</code>.</p> <p>The controller fetches variables using a configurable protocol defined on instantiation. The controller must be configured for EPICS/variable correspondance like the server by passing the EPICS configuration dictionary as defined in the YAML.</p> <p>For our client, we will load our saved variables and create a set of sliders for our inputs and a value table displaying the output variable. This code should be in a separate script from the server setup named <code>client.py</code>.</p> <pre><code>from lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\nfrom lume_epics.client.controller import Controller\nfrom lume_epics.client.widgets.tables import ValueTable\nfrom lume_epics.client.widgets.controls import build_sliders\n\n\nwith open(\"my_variables.yml\", \"r\") as f:\n    input_variables, output_variables = variables_from_yaml(f)\n\nwith open(\"my_epics_config.yml\", \"r\") as f:\n    epics_config = config_from_yaml(f)\n\n# initialize controller to use pvAccess for variable gets\ncontroller = Controller(epics_config)\n\n# build sliders for the command process variable database\nsliders = build_sliders(\n            [input_variables[\"input_1\"], input_variables[\"input_2\"]],\n            controller\n        )\n\n# build value table\nvalue_table = ValueTable(\n                [output_variables[\"output\"]],\n                controller,\n)\n</code></pre> <p>To serve the widgets using bokeh, you must include the bokeh items in the document formatting. These are stored as attributes on the widget. Tutorials for serving these directly using the bokeh server and within Jupyter notebooks are included in Tutorials. For the purpose of this example, a bokeh application can be built by including the following:</p> <pre><code>from bokeh.io import curdoc\nfrom bokeh.layouts import column, row\n\n# collect bokeh sliders from sliders\nbokeh_sliders = [slider.bokeh_slider for slider in sliders]\n\n# render\ncurdoc().title = \"Demo App\"\ncurdoc().add_root(\n            row(\n                column(bokeh_sliders, width=350), column(value_table.table)\n                )\n    )\n\ncurdoc().add_periodic_callback(value_table.update, 250)\n# add callback for updating slider variable to reflect live variable value\nfor slider in sliders:\n    curdoc().add_periodic_callback(slider.update, 250)\n</code></pre>"},{"location":"#running-the-application","title":"Running the application","text":"<p>The application may now be executed using the following commands in separate windows:</p> <p><code>$ python server.py</code></p> <p><code>$ bokeh serve client.py --show</code></p>"},{"location":"#image-variables","title":"Image variables","text":"<p>Models with images can be constructed similarly to the above model.</p> <p>The following example uses the two input variables defined in the above model to create an image from the distribution. In this case, the axis limits of the image output are fixed. This model can also be run using the Bokeh server demo.</p> <p>First, define the variables in <code>variables.yml</code>:</p> <pre><code>input_variables:\n  input1:\n      name: input1\n      type: scalar\n      default: 1\n      range: [0, 256]\n\n  input2:\n      name: input2\n      type: scalar\n      default: 2.0\n      range: [0, 256]\n\noutput_variables:\n  output1:\n    name: output1\n    type: image\n    x_label: \"value1\"\n    y_label: \"value2\"\n    axis_units: [\"mm\", \"mm\"]\n    x_min: 0\n    x_max: 10\n    y_min: 0\n    y_max: 10\n</code></pre> <p>Next create a YAML file <code>my_epics_config.yml</code> describing our EPICS configuration. The variable <code>input1</code> will be served using Channel access using the pvname <code>test:input1</code>. The variables <code>input2</code> and <code>output1</code> will be served using pvAccess.</p> <pre><code>input_variables:\n  input1:\n    pvname: test:input1\n    protocol: ca\n\n  input2:\n    pvname: test:input2\n    protocol: pva\n\noutput_variables:\n  output1:\n    pvname: test:output1\n    protocol: pva\n</code></pre> <p>In <code>server.py</code>:</p> <pre><code>import numpy as np\nfrom lume_model.variables import ScalarInputVariable, ImageOutputVariable\nfrom lume_model.models import BaseModel\nfrom lume_model.utils import save_variables\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\n\nclass ExampleModel(BaseModel):\n    def __init__(self, input_variables: dict=None, output_variables:dict=None):\n        self.input_variables = input_variables\n        self.output_variables = output_variables\n\n    def evaluate(self, input_variables):\n        self.output_variables[\"output1\"].value = np.random.uniform(\n            self.input_variables[\"input1\"].value, # lower dist bound\n            self.input_variables[\"input2\"].value, # upper dist bound\n            (50,50)\n        )\n\n        return list(self.output_variables.values())\n\n\n# must use main for server due to multiprocess spawning\nif __name__ == \"__main\"__:\n    from lume_epics.epics_server import Server\n\n    with open(\"my_variables.yml\", \"r\") as f:\n        input_variables, output_variables = variables_from_yaml(f)\n\n    with open(\"my_epics_config.yml\", \"r\") as f:\n        epics_config = config_from_yaml(f)\n\n    server = Server(\n                ExampleModel,\n                epics_config\n                model_kwargs = {\"input_variables\": input_variables, \"output_variables\": output_variables}\n            )\n\n    # monitor = False does not loop in main thread and can be terminated\n    # with server.stop()\n    server.start(monitor=True)\n    # Runs until keyboard interrupt.\n</code></pre>"},{"location":"#variable-associations","title":"Variable Associations","text":"<p>In the case that image variable axis bounds are dictated by the output of other variables, associations can be created between the bound scalar variable and the axis values of the image variables. This is accomplished by defining the <code>parent</code> attribute on the bound variables and assigning the corresponding variable name to the bound variable attributes of the image variable.</p> <p>For example, the following variables indicate that <code>x_min</code>, <code>x_max</code>, <code>y_min</code>, and <code>y_max</code> define the axis limits of the image output <code>image_output</code>:</p> <pre><code>x_min = ScalarOutputVariable(\n            name=\"x_min\",\n            parent=\"image_output\"\n        )\n\nx_max = ScalarOutputVariable(\n            name=\"x_max\",\n            parent=\"image_output\"\n        )\n\ny_min = ScalarOutputVariable(\n            name=\"y_min\",\n            parent=\"image_output\"\n        ),\ny_max = ScalarOutputVariable(\n            name=\"y_max\"\n            parent=\"image_output\"\n        )\n\nimage_output = ImageOutputVariable(\n    name=\"image_output\",\n    axis_labels=[\"value_1\", \"value_2\"],\n    axis_units=[\"mm\", \"mm\"],\n    x_min_variable=\"x_min\",\n    x_max_variable=\"x_max\",\n    y_min_variable=\"y_min\",\n    y_max_variable=\"y_max\"\n)\n</code></pre>"},{"location":"#serving-from-configuration-files","title":"Serving from configuration files","text":"<p>The model may be served using the variable configuration files as defined in lume-model and the EPICS configuration YAML as defined in EPICS configuration. Additionally, a display may be autogenerated from the same configuration files. These commands are registered as entrypoints.</p> <p>To launch an example NN trained on the Iris data set, first install tensorflow:</p> <pre><code>$ conda install tensorflow\n</code></pre> <p>After installing lume-epics, the server can be launched by:</p> <pre><code>$ serve-from-template examples/files/iris_config.yml examples/files/iris_epics_config.yml\n</code></pre> <p>Protocols to use during serve may be disabled using the --serve-{PROTOCOL} flag. Both Channel Access and pvAccess are served by default.</p> <pre><code>$ serve-from-template examples/files/iris_config.yml examples/files/iris_epics_config.yml\n</code></pre> <p>Likewise, the client can be launched using the command:</p> <pre><code>$ render-from-template examples/files/iris_config.yml examples/files/iris_epics_config.yml\n</code></pre> <p>Additional arguments include the number of steps to show using the striptool and the number of columns to use when rendering the display:</p> <pre><code>$ render-from-template examples/files/iris_config.yml examples/files/iris_epics_config.yml  --striptool-limit 50 --ncol-widgets 5\n</code></pre> <p>Rendering in read-only mode will hide all entry controls and render a striptool for each of the variables.</p> <pre><code>$ render-from-template examples/files/iris_config.yml examples/files/iris_epics_config.yml   --striptool-limit 50 --ncol-widgets 5 --read-only\n</code></pre>"},{"location":"BokehServer/","title":"Bokeh-serve client tutorial","text":"<p>For this tutorial, we will create a simple model which generates an image from sampled from a uniform distribution between the two scalar input variables. This model will be served using the lume-epics server and a bokeh client will be used to display simple sliders for controlling the image, and the image output.</p>"},{"location":"BokehServer/#note","title":"Note:","text":"<p>The code for this example can be found in lume-epics/examples</p>"},{"location":"BokehServer/#set-up-conda-environment","title":"Set up conda environment","text":"<p><code>$ conda create -n lume-epics-demo python=3.7</code></p> <p><code>$ conda activate lume-epics-demo</code></p> <p>Install lume-model and lume-epics from the <code>conda-forge</code>:</p> <p><code>$ conda install numpy lume-model lume-epics -c conda-forge</code></p>"},{"location":"BokehServer/#create-model","title":"Create model","text":"<p>Create a new file named <code>model.py</code>. Set up out model:</p> <pre><code>import numpy as np\nfrom lume_model.variables import ScalarInputVariable, ImageOutputVariable\nfrom lume_model.models import BaseModel\nfrom lume_model.utils import save_variables\n</code></pre> <p>Next, define the demo model. Here, we define the input and output variables as keyword arguments. In order for the evaluate method to execute correctly, these passed variables must be dictionaries of variables with corresponding types and names. These could also be defined as class attributes.</p> <pre><code>class DemoModel(BaseModel):\n    def __init__(self, input_variables=None, output_variables=None):\n        self.input_variables = input_variables\n        self.output_variables = output_variables\n\n    def evaluate(self, input_variables):\n        self.output_variables[\"output1\"].value = np.random.uniform(\n            self.input_variables[\"input1\"].value, # lower dist bound\n            self.input_variables[\"input2\"].value, # upper dist bound\n            (50,50)\n        )\n\n        return list(self.output_variables.values())\n</code></pre> <p>Now, we create a YAML file  <code>my_variables.yml</code> describing our input and output variables using the following format:</p> <pre><code>input_variables:\n  input1:\n      name: input1\n      type: scalar\n      default: 1\n      range: [0, 256]\n\n  input2:\n      name: input2\n      type: scalar\n      default: 2.0\n      range: [0, 256]\n\noutput_variables:\n  output1:\n    name: output1\n    type: image\n    x_label: \"value1\"\n    y_label: \"value2\"\n    axis_units: [\"mm\", \"mm\"]\n    x_min: 0\n    x_max: 10\n    y_min: 0\n    y_max: 10\n</code></pre>"},{"location":"BokehServer/#create-server","title":"Create server","text":"<p>First, we create a YAML file <code>my_epics_config.yml</code> describing our EPICS configuration. The variable <code>input1</code> will be served using Channel access using the pvname <code>test:input1</code>. The variables <code>input2</code> and <code>output1</code> will be served using pvAccess.</p> <pre><code>input_variables:\n  input1:\n    pvname: test:input1\n    protocol: ca\n\n  input2:\n    pvname: test:input2\n    protocol: pva\n\noutput_variables:\n  output1:\n    pvname: test:output1\n    protocol: pva\n</code></pre> <p>Create a new file named <code>server.py</code>. Import the <code>DemoModel</code>, load the variables, and configure the server. Due to the multiprocess spawning of the application, the server must run inside the main conditional of the python script.</p> <pre><code>from examples.model import DemoModel\nfrom lume_epics.epics_server import Server\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\n\n# Server must run in main\nif __name__ == \"__main__\":\n        with open(\"my_variables.yml\", \"r\") as f:\n        input_variables, output_variables = variables_from_yaml(f)\n\n    with open(\"my_epics_config.yml\", \"r\") as f:\n        epics_config = config_from_yaml(f)\n\n    # pass the input + output variable to initialize the classs\n    model_kwargs = {\n        \"input_variables\": input_variables,\n        \"output_variables\": output_variables\n    }\n\n    server = Server(\n        DemoModel,\n        epics_config,\n        model_kwargs=model_kwargs\n    )\n    # monitor = False does not loop in main thread\n    server.start(monitor=True)\n</code></pre>"},{"location":"BokehServer/#set-up-the-client","title":"Set up the client","text":"<p>Create a new file named <code>client.py</code>. Add the following imports:</p> <pre><code>from bokeh.io import curdoc\nfrom bokeh import palettes\nfrom bokeh.layouts import column, row\nfrom bokeh.models import LinearColorMapper\n\nfrom lume_epics.client.controller import Controller\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\n\nfrom lume_epics.client.widgets.plots import ImagePlot\nfrom lume_epics.client.widgets.controls import build_sliders\nfrom lume_epics.client.controller import Controller\n</code></pre> <p>Set up the <code>Controller</code> for interfacing with EPICS process variables:</p> <p>Load variables and epics configuraiton:</p> <pre><code># load variables\nwith open(\"my_variables.yml\", \"r\") as f:\n    input_variables, output_variables = variables_from_yaml(f)\n\n# load epics config\nwith open(\"my_epics_config.yml\", \"r\") as f:\n    epics_config = config_from_yaml(f)\n</code></pre> <pre><code>controller = Controller(epics_config)\n</code></pre> <p>Prepare sliders:</p> <pre><code>\n# use all input variables for slider\n# prepare as list for rendering\ninput_variables = list(input_variables.values())\n\n# build sliders\nsliders = build_sliders(input_variables, controller)\n</code></pre> <p>Setup the image output variable:</p> <pre><code>output_variables = list(output_variables.values())\n\n# create image plot\nimage_plot = ImagePlot(output_variables, controller)\n\n# build plot using a bokeh color map\npal = palettes.viridis(256)\ncolor_mapper = LinearColorMapper(palette=pal, low=0, high=256)\n\nimage_plot.build_plot(color_mapper=color_mapper)\n</code></pre> <p>The image plot will require a callback to continually update the plot to display the lates process variables. Here we define the callback function:</p> <pre><code># Set up image update callback\ndef image_update_callback():\n    image_plot.update()\n\n</code></pre> <p>Render the application using bokeh <code>curdoc()</code> function. The image_plot object's <code>plot</code> attribute must be used in formatting:</p> <pre><code>curdoc().title = \"Demo App\"\ncurdoc().add_root(\n            row(\n                column(sliders, width=350), column(image_plot.plot)\n                )\n    )\n\ncurdoc().add_periodic_callback(image_update_callback, 250)\n</code></pre>"},{"location":"BokehServer/#run-demo","title":"Run demo","text":"<p>Now, open two terminal windows and navigate to the directory with your demo files. Activate the <code>lume-epics-demo</code> environment. In the first, execute the command:</p> <p><code>$ python example/server.py</code></p> <p>In the second, serve the bokeh client using the command:</p> <p><code>$ bokeh serve --show example/client.py</code></p> <p>A browser window will display the user interface. Both the client and server may be terminated with keyboard interrupt (<code>Ctrl+C</code>).</p>"},{"location":"Controller/","title":"Controller","text":"<p>The lume-epics controller serves as the intermediary between variable monitors and process variables served over EPICS.</p>"},{"location":"Controller/#lume_epics.client.controller.Controller","title":"<code>Controller</code>","text":"<p>Controller class used to access process variables. Controllers are used for interfacing with both Channel Access and pvAccess process variables. The controller object is initialized using a single protocol has methods for both getting and setting values on the process variables.</p> <p>Attributes:</p> Name Type Description <code>_protocols</code> <code>dict</code> <p>Dictionary mapping pvname to protocol (\"pva\" for pvAccess, \"ca\" for Channel Access)</p> <code>_context</code> <code>Context</code> <p>P4P threaded context instance for use with pvAccess.</p> <code>_pv_registry</code> <code>dict</code> <p>Registry mapping pvname to dict of value and pv monitor</p> Example <pre><code># create PVAcess controller\nepics_config = {\"input1\": {\"pvname\": \"test:input1\", \"protocol\": \"ca\"}}\ncontroller = Controller(epics_config)\n\nvalue = controller.get_value(\"input1\")\n\ncontroller.close()\n\n</code></pre> Source code in <code>lume_epics/client/controller.py</code> <pre><code>class Controller:\n\"\"\"\n    Controller class used to access process variables. Controllers are used for\n    interfacing with both Channel Access and pvAccess process variables. The\n    controller object is initialized using a single protocol has methods for\n    both getting and setting values on the process variables.\n\n    Attributes:\n        _protocols (dict): Dictionary mapping pvname to protocol (\"pva\" for pvAccess, \"ca\" for\n            Channel Access)\n\n        _context (Context): P4P threaded context instance for use with pvAccess.\n\n        _pv_registry (dict): Registry mapping pvname to dict of value and pv monitor\n\n\n    Example:\n        ```\n        # create PVAcess controller\n        epics_config = {\"input1\": {\"pvname\": \"test:input1\", \"protocol\": \"ca\"}}\n        controller = Controller(epics_config)\n\n        value = controller.get_value(\"input1\")\n\n        controller.close()\n\n        ```\n\n    \"\"\"\n\n    def __init__(self, epics_config: dict):\n\"\"\"\n        Initializes controller. Stores protocol and creates context attribute if\n        using pvAccess.\n\n        Args:\n            epics_config (dict): Dict describing epics configurations\n\n        \"\"\"\n        self._pv_registry = defaultdict()\n        # latest update\n        self.last_update = \"\"\n\n        # dictionary of last updates for all variables\n        self._last_updates = {}\n        self._epics_config = epics_config\n\n        self._context = None\n\n        pva_config = (\n            1\n            if any(\n                [config[\"protocol\"] == \"pva\" for var, config in epics_config.items()]\n            )\n            else 0\n        )\n\n        if pva_config:\n            self._context = Context(\"pva\")\n\n        # utility maps\n        self._pvname_to_varname_map = {\n            config[\"pvname\"]: varname for varname, config in epics_config.items()\n        }\n\n        self._varname_to_pvname_map = {\n            varname: config[\"pvname\"] for varname, config in epics_config.items()\n        }\n\n        # track protocols\n        self._protocols = {\n            epics_config[variable][\"pvname\"]: epics_config[variable][\"protocol\"]\n            for variable in epics_config\n        }\n\n    def _ca_value_callback(self, pvname, value, *args, **kwargs):\n\"\"\"Callback executed by Channel Access monitor.\n\n        Args:\n            pvname (str): Process variable name\n\n            value (Union[np.ndarray, float]): Value to assign to process variable.\n        \"\"\"\n        self._pv_registry[pvname][\"value\"] = value\n\n        update_datetime = datetime.now().strftime(\"%m/%d/%Y, %H:%M:%S\")\n        self.last_update = update_datetime\n        self._last_updates[pvname] = update_datetime\n\n    def _ca_connection_callback(self, *, pvname, conn, pv):\n\"\"\"Callback used for monitoring connection and setting values to None on disconnect.\"\"\"\n        if not conn:\n            self._pv_registry[pvname][\"value\"] = None\n\n    def _pva_value_callback(self, pvname, value):\n\"\"\"Callback executed by pvAccess monitor.\n\n        Args:\n            pvname (str): Process variable name\n\n            value (Union[np.ndarray, float]): Value to assign to process variable.\n        \"\"\"\n        if isinstance(value, Disconnected):\n            self._pv_registry[pvname][\"value\"] = None\n        else:\n            self._pv_registry[pvname][\"value\"] = value\n\n        update_datetime = datetime.now().strftime(\"%m/%d/%Y, %H:%M:%S\")\n        self.last_update = update_datetime\n        self._last_updates[pvname] = update_datetime\n\n    def _set_up_pv_monitor(self, pvname, root=None):\n\"\"\"Set up process variable monitor.\n\n        Args:\n            pvname (str): Process variable name\n\n        \"\"\"\n        if pvname in self._pv_registry:\n            return\n\n        if root:\n            protocol = self._protocols[root]\n\n        else:\n            protocol = self._protocols[pvname]\n\n        if protocol == \"ca\":\n\n            # add to registry (must exist for connection callback)\n            self._pv_registry[pvname] = {\"pv\": None, \"value\": None}\n\n            # create the pv\n            pv_obj = PV(\n                pvname,\n                callback=self._ca_value_callback,\n                connection_callback=self._ca_connection_callback,\n            )\n\n            # update registry\n            self._pv_registry[pvname][\"pv\"] = pv_obj\n\n        elif protocol == \"pva\":\n            cb = partial(self._pva_value_callback, pvname)\n            # populate registry s.t. initially disconnected will populate\n            self._pv_registry[pvname] = {\"pv\": None, \"value\": None}\n\n            # create the monitor obj\n            mon_obj = self._context.monitor(pvname, cb, notify_disconnect=True)\n\n            # update registry with the monitor\n            self._pv_registry[pvname][\"pv\"] = mon_obj\n\n    def get(self, pvname: str, root: str = None) -&gt; np.ndarray:\n\"\"\"\n        Accesses and returns the value of a process variable.\n\n        Args:\n            varname (str): Model variable name\n\n        \"\"\"\n        self._set_up_pv_monitor(pvname, root=root)\n\n        pv = self._pv_registry.get(pvname, None)\n\n        if root:\n            protocol = self._protocols[root]\n\n        else:\n            protocol = self._protocols[pvname]\n\n        if pv:\n            val = pv[\"value\"]\n            if val is None:\n                if protocol == \"ca\":\n                    val = pv[\"pv\"].get()\n\n                elif protocol == \"pva\":\n                    val = self._context.get(pvname)\n\n            return val\n\n        return None\n\n    def get_value(self, varname):\n\"\"\"Gets scalar value of a process variable.\n\n        Args:\n            varname (str): Model variable name\n\n        \"\"\"\n        pvname = self._get_pvname(varname)\n        value = self.get(pvname)\n\n        if value is None:\n            value = DEFAULT_SCALAR_VALUE\n\n        return value\n\n    def get_image(self, varname) -&gt; dict:\n\"\"\"Gets image data via controller protocol.\n\n        Args:\n            varname (str): Model variable name\n\n        \"\"\"\n        pvname = self._get_pvname(varname)\n        image = None\n\n        if self._protocols[pvname] == \"ca\":\n            image_flat = self.get(f\"{pvname}:ArrayData_RBV\", root=pvname)\n            nx = self.get(f\"{pvname}:ArraySizeX_RBV\", root=pvname)\n            ny = self.get(f\"{pvname}:ArraySizeY_RBV\", root=pvname)\n            x = self.get(f\"{pvname}:MinX_RBV\", root=pvname)\n            y = self.get(f\"{pvname}:MinY_RBV\", root=pvname)\n            x_max = self.get(f\"{pvname}:MaxX_RBV\", root=pvname)\n            y_max = self.get(f\"{pvname}:MaxY_RBV\", root=pvname)\n\n            if all(\n                [\n                    image_def is not None\n                    for image_def in [image_flat, nx, ny, x, y, x_max, y_max]\n                ]\n            ):\n                dw = x_max - x\n                dh = y_max - y\n\n                image = image_flat.reshape(int(nx), int(ny))\n\n        elif self._protocols[pvname] == \"pva\":\n            # context returns numpy array with WRITEABLE=False\n            # copy to manipulate array below\n\n            image = self.get(pvname)\n\n            if image is not None:\n                attrib = image.attrib\n                x = attrib[\"x_min\"]\n                y = attrib[\"y_min\"]\n                dw = attrib[\"x_max\"] - attrib[\"x_min\"]\n                dh = attrib[\"y_max\"] - attrib[\"y_min\"]\n                image = copy.copy(image)\n\n        if image is not None:\n            return {\n                \"image\": [image],\n                \"x\": [x],\n                \"y\": [y],\n                \"dw\": [dw],\n                \"dh\": [dh],\n            }\n\n        else:\n            return DEFAULT_IMAGE_DATA\n\n    def get_array(self, varname) -&gt; dict:\n\"\"\"Gets array data via controller protocol.\n\n        Args:\n            varname (str): Model variable name\n\n        \"\"\"\n        pvname = self._get_pvname(varname)\n        array = None\n        if self._protocols[pvname] == \"ca\":\n            array_flat = self.get(f\"{pvname}:ArrayData_RBV\", root=pvname)\n            shape = self.get(f\"{pvname}:ArraySize_RBV\", root=pvname)\n\n            if all([array_def is not None for array_def in [array_flat, shape]]):\n\n                array = np.array(array_flat).reshape(shape)\n\n        elif self._protocols[pvname] == \"pva\":\n            # context returns numpy array with WRITEABLE=False\n            # copy to manipulate array below\n\n            array = self.get(pvname)\n\n        if array is not None:\n            return array\n        else:\n            return np.array([])\n\n    def put(self, varname, value: float, timeout=1.0) -&gt; None:\n\"\"\"Assign the value of a scalar process variable.\n\n        Args:\n            varname (str): Model variable name\n\n            value (float): Value to assing to process variable.\n\n            timeout (float): Operation timeout in seconds\n\n        \"\"\"\n        pvname = self._get_pvname(varname)\n        self._set_up_pv_monitor(pvname)\n\n        # allow no puts before a value has been collected\n        registered = self.get(pvname)\n\n        # if the value is registered\n        if registered is not None:\n            if self._protocols[pvname] == \"ca\":\n                self._pv_registry[pvname][\"pv\"].put(value, timeout=timeout)\n\n            elif self._protocols[pvname] == \"pva\":\n                self._context.put(pvname, value, throw=False, timeout=timeout)\n\n        else:\n            logger.debug(f\"No initial value set for {pvname}.\")\n\n    def put_image(\n        self,\n        varname,\n        image_array: np.ndarray = None,\n        x_min: float = None,\n        x_max: float = None,\n        y_min: float = None,\n        y_max: float = None,\n        timeout: float = 1.0,\n    ) -&gt; None:\n\"\"\"Assign the value of a image process variable. Allows updates to individual attributes.\n\n        Args:\n            varname (str): Model variable name\n\n            image_array (np.ndarray): Value to assing to process variable.\n\n            x_min (float): Minimum x value\n\n            x_max (float): Maximum x value\n\n            y_min (float): Minimum y value\n\n            y_max (float): Maximum y value\n\n            timeout (float): Operation timeout in seconds\n\n        \"\"\"\n        pvname = self._get_pvname(varname)\n        self._set_up_pv_monitor(pvname, root=pvname)\n\n        # allow no puts before a value has been collected\n        registered = self.get_image(varname)\n\n        # if the value is registered\n        if registered is not None:\n            if self._protocols[pvname] == \"ca\":\n\n                if image_array is not None:\n                    self._pv_registry[f\"{pvname}:ArrayData_RBV\"][\"pv\"].put(\n                        image_array.flatten(), timeout=timeout\n                    )\n\n                if x_min:\n                    self._pv_registry[f\"{pvname}:MinX_RBV\"][\"pv\"].put(\n                        x_min, timeout=timeout\n                    )\n\n                if x_max:\n                    self._pv_registry[f\"{pvname}:MaxX_RBV\"][\"pv\"].put(\n                        x_max, timeout=timeout\n                    )\n\n                if y_min:\n                    self._pv_registry[f\"{pvname}:MinY_RBV\"][\"pv\"].put(\n                        y_min, timeout=timeout\n                    )\n\n                if y_max:\n                    self._pv_registry[f\"{pvname}:MaxY_RBV\"][\"pv\"].put(\n                        y_max, timeout=timeout\n                    )\n\n            elif self._protocols[pvname] == \"pva\":\n\n                # compose normative type\n                pv = self._pv_registry[pvname]\n                pv_array = pv[\"value\"]\n\n                if image_array:\n                    image_array.attrib = pv_array.attrib\n\n                else:\n                    image_array = pv_array\n\n                if x_min:\n                    image_array.attrib.x_min = x_min\n\n                if x_max:\n                    image_array.attrib.x_max = x_max\n\n                if y_min:\n                    image_array.attrib.y_min = y_min\n\n                if y_max:\n                    image_array.attrib.y_max = y_max\n\n                self._context.put(pvname, image_array, throw=False, timeout=timeout)\n\n        else:\n            logger.debug(f\"No initial value set for {pvname}.\")\n\n    def put_array(\n        self,\n        varname,\n        array: np.ndarray = None,\n        timeout: float = 1.0,\n    ) -&gt; None:\n\"\"\"Assign the value of an array process variable. Allows updates to individual attributes.\n\n        Args:\n            varname (str): Model variable name\n\n            array (np.ndarray): Value to assing to process variable.\n\n            timeout (float): Operation timeout in seconds\n\n        \"\"\"\n        pvname = self._get_pvname(varname)\n        self._set_up_pv_monitor(pvname, root=pvname)\n\n        # allow no puts before a value has been collected\n        registered = self.get_array(pvname)\n\n        # if the value is registered\n        if registered is not None:\n            if self._protocols[pvname] == \"ca\":\n\n                if array is not None:\n                    self._pv_registry[f\"{pvname}:ArrayData_RBV\"][\"pv\"].put(\n                        array.flatten(), timeout=timeout\n                    )\n\n            elif self._protocols[pvname] == \"pva\":\n\n                # compose normative type\n                pv = self._pv_registry[pvname]\n                array = pv[\"value\"]\n\n                self._context.put(pvname, array, throw=False, timeout=timeout)\n\n        else:\n            logger.debug(f\"No initial value set for {pvname}.\")\n\n    def close(self):\n        if self._context is not None:\n            self._context.close()\n\n    def _get_pvname(self, varname):\n\n        pvname = self._varname_to_pvname_map.get(varname)\n        if not pvname:\n            raise ValueError(\n                f\"{varname} has not been configured with EPICS controller.\"\n            )\n\n        else:\n            return pvname\n</code></pre>"},{"location":"Controller/#lume_epics.client.controller.Controller.__init__","title":"<code>__init__(epics_config)</code>","text":"<p>Initializes controller. Stores protocol and creates context attribute if using pvAccess.</p> <p>Parameters:</p> Name Type Description Default <code>epics_config</code> <code>dict</code> <p>Dict describing epics configurations</p> required Source code in <code>lume_epics/client/controller.py</code> <pre><code>def __init__(self, epics_config: dict):\n\"\"\"\n    Initializes controller. Stores protocol and creates context attribute if\n    using pvAccess.\n\n    Args:\n        epics_config (dict): Dict describing epics configurations\n\n    \"\"\"\n    self._pv_registry = defaultdict()\n    # latest update\n    self.last_update = \"\"\n\n    # dictionary of last updates for all variables\n    self._last_updates = {}\n    self._epics_config = epics_config\n\n    self._context = None\n\n    pva_config = (\n        1\n        if any(\n            [config[\"protocol\"] == \"pva\" for var, config in epics_config.items()]\n        )\n        else 0\n    )\n\n    if pva_config:\n        self._context = Context(\"pva\")\n\n    # utility maps\n    self._pvname_to_varname_map = {\n        config[\"pvname\"]: varname for varname, config in epics_config.items()\n    }\n\n    self._varname_to_pvname_map = {\n        varname: config[\"pvname\"] for varname, config in epics_config.items()\n    }\n\n    # track protocols\n    self._protocols = {\n        epics_config[variable][\"pvname\"]: epics_config[variable][\"protocol\"]\n        for variable in epics_config\n    }\n</code></pre>"},{"location":"Controller/#lume_epics.client.controller.Controller.get","title":"<code>get(pvname, root=None)</code>","text":"<p>Accesses and returns the value of a process variable.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>Model variable name</p> required Source code in <code>lume_epics/client/controller.py</code> <pre><code>def get(self, pvname: str, root: str = None) -&gt; np.ndarray:\n\"\"\"\n    Accesses and returns the value of a process variable.\n\n    Args:\n        varname (str): Model variable name\n\n    \"\"\"\n    self._set_up_pv_monitor(pvname, root=root)\n\n    pv = self._pv_registry.get(pvname, None)\n\n    if root:\n        protocol = self._protocols[root]\n\n    else:\n        protocol = self._protocols[pvname]\n\n    if pv:\n        val = pv[\"value\"]\n        if val is None:\n            if protocol == \"ca\":\n                val = pv[\"pv\"].get()\n\n            elif protocol == \"pva\":\n                val = self._context.get(pvname)\n\n        return val\n\n    return None\n</code></pre>"},{"location":"Controller/#lume_epics.client.controller.Controller.get_array","title":"<code>get_array(varname)</code>","text":"<p>Gets array data via controller protocol.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>Model variable name</p> required Source code in <code>lume_epics/client/controller.py</code> <pre><code>def get_array(self, varname) -&gt; dict:\n\"\"\"Gets array data via controller protocol.\n\n    Args:\n        varname (str): Model variable name\n\n    \"\"\"\n    pvname = self._get_pvname(varname)\n    array = None\n    if self._protocols[pvname] == \"ca\":\n        array_flat = self.get(f\"{pvname}:ArrayData_RBV\", root=pvname)\n        shape = self.get(f\"{pvname}:ArraySize_RBV\", root=pvname)\n\n        if all([array_def is not None for array_def in [array_flat, shape]]):\n\n            array = np.array(array_flat).reshape(shape)\n\n    elif self._protocols[pvname] == \"pva\":\n        # context returns numpy array with WRITEABLE=False\n        # copy to manipulate array below\n\n        array = self.get(pvname)\n\n    if array is not None:\n        return array\n    else:\n        return np.array([])\n</code></pre>"},{"location":"Controller/#lume_epics.client.controller.Controller.get_image","title":"<code>get_image(varname)</code>","text":"<p>Gets image data via controller protocol.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>Model variable name</p> required Source code in <code>lume_epics/client/controller.py</code> <pre><code>def get_image(self, varname) -&gt; dict:\n\"\"\"Gets image data via controller protocol.\n\n    Args:\n        varname (str): Model variable name\n\n    \"\"\"\n    pvname = self._get_pvname(varname)\n    image = None\n\n    if self._protocols[pvname] == \"ca\":\n        image_flat = self.get(f\"{pvname}:ArrayData_RBV\", root=pvname)\n        nx = self.get(f\"{pvname}:ArraySizeX_RBV\", root=pvname)\n        ny = self.get(f\"{pvname}:ArraySizeY_RBV\", root=pvname)\n        x = self.get(f\"{pvname}:MinX_RBV\", root=pvname)\n        y = self.get(f\"{pvname}:MinY_RBV\", root=pvname)\n        x_max = self.get(f\"{pvname}:MaxX_RBV\", root=pvname)\n        y_max = self.get(f\"{pvname}:MaxY_RBV\", root=pvname)\n\n        if all(\n            [\n                image_def is not None\n                for image_def in [image_flat, nx, ny, x, y, x_max, y_max]\n            ]\n        ):\n            dw = x_max - x\n            dh = y_max - y\n\n            image = image_flat.reshape(int(nx), int(ny))\n\n    elif self._protocols[pvname] == \"pva\":\n        # context returns numpy array with WRITEABLE=False\n        # copy to manipulate array below\n\n        image = self.get(pvname)\n\n        if image is not None:\n            attrib = image.attrib\n            x = attrib[\"x_min\"]\n            y = attrib[\"y_min\"]\n            dw = attrib[\"x_max\"] - attrib[\"x_min\"]\n            dh = attrib[\"y_max\"] - attrib[\"y_min\"]\n            image = copy.copy(image)\n\n    if image is not None:\n        return {\n            \"image\": [image],\n            \"x\": [x],\n            \"y\": [y],\n            \"dw\": [dw],\n            \"dh\": [dh],\n        }\n\n    else:\n        return DEFAULT_IMAGE_DATA\n</code></pre>"},{"location":"Controller/#lume_epics.client.controller.Controller.get_value","title":"<code>get_value(varname)</code>","text":"<p>Gets scalar value of a process variable.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>Model variable name</p> required Source code in <code>lume_epics/client/controller.py</code> <pre><code>def get_value(self, varname):\n\"\"\"Gets scalar value of a process variable.\n\n    Args:\n        varname (str): Model variable name\n\n    \"\"\"\n    pvname = self._get_pvname(varname)\n    value = self.get(pvname)\n\n    if value is None:\n        value = DEFAULT_SCALAR_VALUE\n\n    return value\n</code></pre>"},{"location":"Controller/#lume_epics.client.controller.Controller.put","title":"<code>put(varname, value, timeout=1.0)</code>","text":"<p>Assign the value of a scalar process variable.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>Model variable name</p> required <code>value</code> <code>float</code> <p>Value to assing to process variable.</p> required <code>timeout</code> <code>float</code> <p>Operation timeout in seconds</p> <code>1.0</code> Source code in <code>lume_epics/client/controller.py</code> <pre><code>def put(self, varname, value: float, timeout=1.0) -&gt; None:\n\"\"\"Assign the value of a scalar process variable.\n\n    Args:\n        varname (str): Model variable name\n\n        value (float): Value to assing to process variable.\n\n        timeout (float): Operation timeout in seconds\n\n    \"\"\"\n    pvname = self._get_pvname(varname)\n    self._set_up_pv_monitor(pvname)\n\n    # allow no puts before a value has been collected\n    registered = self.get(pvname)\n\n    # if the value is registered\n    if registered is not None:\n        if self._protocols[pvname] == \"ca\":\n            self._pv_registry[pvname][\"pv\"].put(value, timeout=timeout)\n\n        elif self._protocols[pvname] == \"pva\":\n            self._context.put(pvname, value, throw=False, timeout=timeout)\n\n    else:\n        logger.debug(f\"No initial value set for {pvname}.\")\n</code></pre>"},{"location":"Controller/#lume_epics.client.controller.Controller.put_array","title":"<code>put_array(varname, array=None, timeout=1.0)</code>","text":"<p>Assign the value of an array process variable. Allows updates to individual attributes.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>Model variable name</p> required <code>array</code> <code>np.ndarray</code> <p>Value to assing to process variable.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Operation timeout in seconds</p> <code>1.0</code> Source code in <code>lume_epics/client/controller.py</code> <pre><code>def put_array(\n    self,\n    varname,\n    array: np.ndarray = None,\n    timeout: float = 1.0,\n) -&gt; None:\n\"\"\"Assign the value of an array process variable. Allows updates to individual attributes.\n\n    Args:\n        varname (str): Model variable name\n\n        array (np.ndarray): Value to assing to process variable.\n\n        timeout (float): Operation timeout in seconds\n\n    \"\"\"\n    pvname = self._get_pvname(varname)\n    self._set_up_pv_monitor(pvname, root=pvname)\n\n    # allow no puts before a value has been collected\n    registered = self.get_array(pvname)\n\n    # if the value is registered\n    if registered is not None:\n        if self._protocols[pvname] == \"ca\":\n\n            if array is not None:\n                self._pv_registry[f\"{pvname}:ArrayData_RBV\"][\"pv\"].put(\n                    array.flatten(), timeout=timeout\n                )\n\n        elif self._protocols[pvname] == \"pva\":\n\n            # compose normative type\n            pv = self._pv_registry[pvname]\n            array = pv[\"value\"]\n\n            self._context.put(pvname, array, throw=False, timeout=timeout)\n\n    else:\n        logger.debug(f\"No initial value set for {pvname}.\")\n</code></pre>"},{"location":"Controller/#lume_epics.client.controller.Controller.put_image","title":"<code>put_image(varname, image_array=None, x_min=None, x_max=None, y_min=None, y_max=None, timeout=1.0)</code>","text":"<p>Assign the value of a image process variable. Allows updates to individual attributes.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>Model variable name</p> required <code>image_array</code> <code>np.ndarray</code> <p>Value to assing to process variable.</p> <code>None</code> <code>x_min</code> <code>float</code> <p>Minimum x value</p> <code>None</code> <code>x_max</code> <code>float</code> <p>Maximum x value</p> <code>None</code> <code>y_min</code> <code>float</code> <p>Minimum y value</p> <code>None</code> <code>y_max</code> <code>float</code> <p>Maximum y value</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Operation timeout in seconds</p> <code>1.0</code> Source code in <code>lume_epics/client/controller.py</code> <pre><code>def put_image(\n    self,\n    varname,\n    image_array: np.ndarray = None,\n    x_min: float = None,\n    x_max: float = None,\n    y_min: float = None,\n    y_max: float = None,\n    timeout: float = 1.0,\n) -&gt; None:\n\"\"\"Assign the value of a image process variable. Allows updates to individual attributes.\n\n    Args:\n        varname (str): Model variable name\n\n        image_array (np.ndarray): Value to assing to process variable.\n\n        x_min (float): Minimum x value\n\n        x_max (float): Maximum x value\n\n        y_min (float): Minimum y value\n\n        y_max (float): Maximum y value\n\n        timeout (float): Operation timeout in seconds\n\n    \"\"\"\n    pvname = self._get_pvname(varname)\n    self._set_up_pv_monitor(pvname, root=pvname)\n\n    # allow no puts before a value has been collected\n    registered = self.get_image(varname)\n\n    # if the value is registered\n    if registered is not None:\n        if self._protocols[pvname] == \"ca\":\n\n            if image_array is not None:\n                self._pv_registry[f\"{pvname}:ArrayData_RBV\"][\"pv\"].put(\n                    image_array.flatten(), timeout=timeout\n                )\n\n            if x_min:\n                self._pv_registry[f\"{pvname}:MinX_RBV\"][\"pv\"].put(\n                    x_min, timeout=timeout\n                )\n\n            if x_max:\n                self._pv_registry[f\"{pvname}:MaxX_RBV\"][\"pv\"].put(\n                    x_max, timeout=timeout\n                )\n\n            if y_min:\n                self._pv_registry[f\"{pvname}:MinY_RBV\"][\"pv\"].put(\n                    y_min, timeout=timeout\n                )\n\n            if y_max:\n                self._pv_registry[f\"{pvname}:MaxY_RBV\"][\"pv\"].put(\n                    y_max, timeout=timeout\n                )\n\n        elif self._protocols[pvname] == \"pva\":\n\n            # compose normative type\n            pv = self._pv_registry[pvname]\n            pv_array = pv[\"value\"]\n\n            if image_array:\n                image_array.attrib = pv_array.attrib\n\n            else:\n                image_array = pv_array\n\n            if x_min:\n                image_array.attrib.x_min = x_min\n\n            if x_max:\n                image_array.attrib.x_max = x_max\n\n            if y_min:\n                image_array.attrib.y_min = y_min\n\n            if y_max:\n                image_array.attrib.y_max = y_max\n\n            self._context.put(pvname, image_array, throw=False, timeout=timeout)\n\n    else:\n        logger.debug(f\"No initial value set for {pvname}.\")\n</code></pre>"},{"location":"EPICS/","title":"EPICS configuration","text":"<p>The server expects a dictionary defining the EPICS configuration for each model input and output variable. This may be loaded using the utility function <code>config_from_yaml(file)</code> packaged in <code>lume_epics.utils</code>. The YAML file should be structured as below:</p> <pre><code>input_variables:\n  input1:\n    pvname: test:input1\n    protocol: ca\n    serve: false\n\n  input2:\n    pvname: test:input2\n    protocol: pva\n\noutput_variables:\n  output1:\n    pvname: test:output1\n    protocol: pva\n\n  output2:\n    pvname: test:output2\n    protocol: pva\n\n  output3:\n    pvname: test:output3\n    protocol: pva\n</code></pre> <p>The optional field <code>serve</code> for each variable accepts a boolean defaulting to true. If false, this assumes that the PV is hosted externally monitors will be used to execute the model on changes to variable values.</p> <p>The client controller <code>lume_epics.client.controller.Controller</code> is also initialized using the EPICS configuration dictionary and a common file may be used for a project, though the serve field is unimportant to the controller.</p> <p>Over pvAccess, you also have the option to host a summary process variable:</p> <pre><code>input_variables:\n  input1:\n    pvname: test:input1\n    protocol: ca\n    serve: false\n\n  input2:\n    pvname: test:input2\n    protocol: pva\n\noutput_variables:\n  output1:\n    pvname: test:output1\n    protocol: pva\n\n  output2:\n    pvname: test:output2\n    protocol: pva\n\n  output3:\n    pvname: test:output3\n    protocol: pva\n\nsummary:\n  pvname: test:summary_variable\n  owner: Jacqueline Garrahan\n  date_published: 1/27/22\n  description: A basic epics configuration\n  id: model1\n</code></pre> <p>You can also serve output variables as a pvAccess structure:</p> <pre><code>input_variables:\n  input1:\n    pvname: test:input1\n    protocol: ca\n    serve: false\n\n  input2:\n    pvname: test:input2\n    protocol: pva\n\noutput_variables:\n  pvname: test:output\n  protocol: pva\n  fields:\n    - output1\n    - output2\n    - output3\n\nsummary:\n  pvname: test:summary_variable\n  owner: Jacqueline Garrahan\n  date_published: 1/27/22\n  description: A basic epics configuration\n  id: model1\n</code></pre>"},{"location":"EPICS/#epics-environment-configuration","title":"EPICS environment configuration","text":"<p>The environment variables passed to the server subprocesses may be specified directly in the server construction. Otherwise, the variables will be inherited from the shell environment variables, defaulting to EPICS defaults in their absence. The following example may be run from the repository root:</p> <pre><code>from examples.model import DemoModel\nfrom lume_epics.epics_server import Server\nfrom lume_epics.utils import config_from_yaml\nfrom lume_model.utils import variables_from_yaml\n\n# must use main conditional due to multiprocess spawning\nif __name__ == \"__main__\":\n    with open(\"examples/files/demo_config.yml\", \"r\") as f:\n        input_variables, output_variables = variables_from_yaml(f)\n\n    with open(\"examples/files/epics_config.yml\", \"r\") as f:\n        epics_config = config_from_yaml(f)\n\n    prefix = \"test\"\n    server = Server(\n        DemoModel,\n        epics_config,\n        model_kwargs={\"input_variables\": input_variables, \"output_variables\": output_variables},\n        epics_config={\"EPICS_CA_SERVER_PORT\": 63000, \"EPICS_PVA_SERVER_PORT\": 63001}\n    )\n    # monitor = False does not loop in main thread\n    server.start(monitor=True)\n</code></pre> <p>A description of the channel access variables may be found here. pvAccess variables take a similar form (substituting PVA for CA).</p>"},{"location":"Install/","title":"Installation","text":"<p>Lume-epics may be installed via conda on the <code>conda-forge</code> channel:  <code>$ conda install lume-epics -c conda-forge</code> </p> <p>Alternatively, you may install from the GitHub repository using:  <code>$ pip install https://github.com/slaclab/lume-epics.git</code> </p>"},{"location":"Model/","title":"Model","text":"<p>This module is used for executing callbacks on the user's BaseModel subclass for use with the EPICS server defined in lume_epics.epics_server. The BaseModel must be defined using the guidelines outlined in the lume_model.models module to be surfaced using the BaseModel class.</p>"},{"location":"Model/#lume_epics.model.OnlineModel","title":"<code>OnlineModel</code>","text":"<p>Class for executing surrogate model.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>BaseModel</code> <p>Model for execution.</p> <code>input_variables</code> <code>Dict[str, InputVariable]</code> <p>List of lume-model variables to use as inputs.</p> <code>ouput_variables</code> <code>Dict[str, OutputVariable]</code> <p>List of lume-model variables to use as outputs.</p> Source code in <code>lume_epics/model.py</code> <pre><code>class OnlineModel:\n\"\"\"\n    Class for executing surrogate model.\n\n    Attributes:\n        model (BaseModel): Model for execution.\n\n        input_variables (Dict[str, InputVariable]): List of lume-model variables to use as inputs.\n\n        ouput_variables (Dict[str, OutputVariable]): List of lume-model variables to use as outputs.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        model: BaseModel,\n    ) -&gt; None:\n\"\"\"\n        Initialize OnlineModel with the base model class.\n\n        Args:\n            model (BaseModel): Instantiated model.\n\n        \"\"\"\n        self.model = model\n\n        self.input_variables = self.model.input_variables\n        self.output_variables = self.model.output_variables\n\n    def run(\n        self, input_variables: Dict[str, InputVariable]\n    ) -&gt; Dict[str, OutputVariable]:\n\"\"\"\n        Executes both scalar and image model given process variable value inputs.\n\n        Args:\n            input_variables (Dict[str, InputVariable]): Dict of lume-model variables to use as inputs.\n\n        \"\"\"\n        # update input variables and get state representation\n        self.input_variables = input_variables\n\n        # update output variable state\n        logger.info(\"Running model\")\n        t1 = time.time()\n        self.output_variables = self.model.evaluate(self.input_variables)\n        t2 = time.time()\n\n        logger.info(\"Ellapsed time: %s\", str(t2 - t1))\n\n        return self.output_variables\n</code></pre>"},{"location":"Model/#lume_epics.model.OnlineModel.__init__","title":"<code>__init__(model)</code>","text":"<p>Initialize OnlineModel with the base model class.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel</code> <p>Instantiated model.</p> required Source code in <code>lume_epics/model.py</code> <pre><code>def __init__(\n    self,\n    model: BaseModel,\n) -&gt; None:\n\"\"\"\n    Initialize OnlineModel with the base model class.\n\n    Args:\n        model (BaseModel): Instantiated model.\n\n    \"\"\"\n    self.model = model\n\n    self.input_variables = self.model.input_variables\n    self.output_variables = self.model.output_variables\n</code></pre>"},{"location":"Model/#lume_epics.model.OnlineModel.run","title":"<code>run(input_variables)</code>","text":"<p>Executes both scalar and image model given process variable value inputs.</p> <p>Parameters:</p> Name Type Description Default <code>input_variables</code> <code>Dict[str, InputVariable]</code> <p>Dict of lume-model variables to use as inputs.</p> required Source code in <code>lume_epics/model.py</code> <pre><code>def run(\n    self, input_variables: Dict[str, InputVariable]\n) -&gt; Dict[str, OutputVariable]:\n\"\"\"\n    Executes both scalar and image model given process variable value inputs.\n\n    Args:\n        input_variables (Dict[str, InputVariable]): Dict of lume-model variables to use as inputs.\n\n    \"\"\"\n    # update input variables and get state representation\n    self.input_variables = input_variables\n\n    # update output variable state\n    logger.info(\"Running model\")\n    t1 = time.time()\n    self.output_variables = self.model.evaluate(self.input_variables)\n    t2 = time.time()\n\n    logger.info(\"Ellapsed time: %s\", str(t2 - t1))\n\n    return self.output_variables\n</code></pre>"},{"location":"Monitors/","title":"Monitors","text":"<p>Monitors interface with widgets to surface process variable information. They are initialized using a lume-model variable and a controller used to access values over EPICs.</p>"},{"location":"Monitors/#lume_epics.client.monitors.PVImage","title":"<code>PVImage</code>","text":"<p>Monitor for updating and formatting image data.</p> <p>Attributes:</p> Name Type Description <code>variable</code> <code>ImageVariable</code> <p>Image process variable to be displayed.</p> <code>controller</code> <code>Controller</code> <p>Controller object for accessing process variable.</p> <code>pvname</code> <code>str</code> <p>Name of the process variable to access.</p> <code>axis_units</code> <code>str</code> <p>Units associated with the image axes.</p> <code>axis_labels</code> <code>str</code> <p>Labels associated with the image axes.</p> Source code in <code>lume_epics/client/monitors.py</code> <pre><code>class PVImage:\n\"\"\"\n    Monitor for updating and formatting image data.\n\n    Attributes:\n        variable (ImageVariable): Image process variable to be displayed.\n\n        controller (Controller): Controller object for accessing process variable.\n\n        pvname (str): Name of the process variable to access.\n\n        axis_units (str): Units associated with the image axes.\n\n        axis_labels (str): Labels associated with the image axes.\n\n    \"\"\"\n\n    def __init__(self, variable: ImageVariable, controller: Controller,) -&gt; None:\n\"\"\"Initialize monitor for an image variable.\n\n        Args:\n            variable (ImageVariable): Image process variable to be displayed.\n\n            controller (Controller): Controller object for accessing process variable.\n\n        \"\"\"\n        self.units = None\n        # check if units has been set\n        if \"units\" in variable.__fields_set__:\n            self.units = variable.units.split(\":\")\n\n        self.varname = variable.name\n        self.controller = controller\n        self.axis_labels = variable.axis_labels\n        self.axis_units = variable.axis_units\n\n    def poll(self) -&gt; Dict[str, list]:\n\"\"\"Collects image data and builds image data dictionary.\n\n        \"\"\"\n\n        return self.controller.get_image(self.varname)\n</code></pre>"},{"location":"Monitors/#lume_epics.client.monitors.PVImage.__init__","title":"<code>__init__(variable, controller)</code>","text":"<p>Initialize monitor for an image variable.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>ImageVariable</code> <p>Image process variable to be displayed.</p> required <code>controller</code> <code>Controller</code> <p>Controller object for accessing process variable.</p> required Source code in <code>lume_epics/client/monitors.py</code> <pre><code>def __init__(self, variable: ImageVariable, controller: Controller,) -&gt; None:\n\"\"\"Initialize monitor for an image variable.\n\n    Args:\n        variable (ImageVariable): Image process variable to be displayed.\n\n        controller (Controller): Controller object for accessing process variable.\n\n    \"\"\"\n    self.units = None\n    # check if units has been set\n    if \"units\" in variable.__fields_set__:\n        self.units = variable.units.split(\":\")\n\n    self.varname = variable.name\n    self.controller = controller\n    self.axis_labels = variable.axis_labels\n    self.axis_units = variable.axis_units\n</code></pre>"},{"location":"Monitors/#lume_epics.client.monitors.PVImage.poll","title":"<code>poll()</code>","text":"<p>Collects image data and builds image data dictionary.</p> Source code in <code>lume_epics/client/monitors.py</code> <pre><code>def poll(self) -&gt; Dict[str, list]:\n\"\"\"Collects image data and builds image data dictionary.\n\n    \"\"\"\n\n    return self.controller.get_image(self.varname)\n</code></pre>"},{"location":"Monitors/#lume_epics.client.monitors.PVScalar","title":"<code>PVScalar</code>","text":"<p>Monitor for scalar process variables.</p> <p>Attributes:</p> Name Type Description <code>variable</code> <code>ScalarVariable</code> <p>Variable to monitor for value.</p> <code>controller</code> <code>Controller</code> <p>Controller object for accessing process variable.</p> <code>units</code> <code>str</code> <p>Units associated with the variable.</p> <code>varname</code> <code>str</code> <p>Name of the model variable to access.</p> Source code in <code>lume_epics/client/monitors.py</code> <pre><code>class PVScalar:\n\"\"\"\n    Monitor for scalar process variables.\n\n    Attributes:\n        variable (ScalarVariable): Variable to monitor for value.\n\n        controller (Controller): Controller object for accessing process variable.\n\n        units (str): Units associated with the variable.\n\n        varname (str): Name of the model variable to access.\n\n    \"\"\"\n\n    def __init__(self, variable: ScalarVariable, controller: Controller,) -&gt; None:\n\"\"\"Initializes monitor attributes.\n\n        Args:\n            variable (ScalarVariable):  Variable to monitor for value.\n\n            controller (Controller): Controller object for accessing process variable.\n        \"\"\"\n        self.units = None\n        # check if units has been set\n        if \"units\" in variable.__fields_set__:\n            self.units = variable.units\n        self.varname = variable.name\n        self.controller = controller\n\n    def poll(self) -&gt; Tuple[np.ndarray]:\n\"\"\"\n        Poll variable for value,\n\n        \"\"\"\n        return self.controller.get_value(self.varname)\n</code></pre>"},{"location":"Monitors/#lume_epics.client.monitors.PVScalar.__init__","title":"<code>__init__(variable, controller)</code>","text":"<p>Initializes monitor attributes.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>ScalarVariable</code> <p>Variable to monitor for value.</p> required <code>controller</code> <code>Controller</code> <p>Controller object for accessing process variable.</p> required Source code in <code>lume_epics/client/monitors.py</code> <pre><code>def __init__(self, variable: ScalarVariable, controller: Controller,) -&gt; None:\n\"\"\"Initializes monitor attributes.\n\n    Args:\n        variable (ScalarVariable):  Variable to monitor for value.\n\n        controller (Controller): Controller object for accessing process variable.\n    \"\"\"\n    self.units = None\n    # check if units has been set\n    if \"units\" in variable.__fields_set__:\n        self.units = variable.units\n    self.varname = variable.name\n    self.controller = controller\n</code></pre>"},{"location":"Monitors/#lume_epics.client.monitors.PVScalar.poll","title":"<code>poll()</code>","text":"<p>Poll variable for value,</p> Source code in <code>lume_epics/client/monitors.py</code> <pre><code>def poll(self) -&gt; Tuple[np.ndarray]:\n\"\"\"\n    Poll variable for value,\n\n    \"\"\"\n    return self.controller.get_value(self.varname)\n</code></pre>"},{"location":"Monitors/#lume_epics.client.monitors.PVTimeSeries","title":"<code>PVTimeSeries</code>","text":"<p>Monitor for time series variables.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>np.ndarray</code> <p>Array of times sampled.</p> <code>data</code> <code>np.ndarray</code> <p>Array of sampled data.</p> <code>variable</code> <code>ScalarVariable</code> <p>Variable monitored for time series.</p> <code>controller</code> <code>Controller</code> <p>Controller object for accessing process variable.</p> <code>units</code> <code>str</code> <p>Units associated with the variable</p> <code>varname</code> <code>str</code> <p>Name of the model variable to access</p> Source code in <code>lume_epics/client/monitors.py</code> <pre><code>class PVTimeSeries:\n\"\"\"\n    Monitor for time series variables.\n\n    Attributes:\n        time (np.ndarray): Array of times sampled.\n\n        data (np.ndarray): Array of sampled data.\n\n        variable (ScalarVariable): Variable monitored for time series.\n\n        controller (Controller): Controller object for accessing process variable.\n\n        units (str): Units associated with the variable\n\n        varname (str): Name of the model variable to access\n\n    \"\"\"\n\n    def __init__(self, variable: ScalarVariable, controller: Controller,) -&gt; None:\n\"\"\"Initializes monitor attributes.\n\n        Args:\n            variable (ScalarVariable): Variable to monitor for time series\n\n            controller (Controller): Controller object for accessing process variable.\n\n        \"\"\"\n        self.varname = variable.name\n        self.tstart = time.time()\n        self.time = np.array([])\n        self.data = np.array([])\n\n        self.units = None\n        # check if units has been set\n        if \"units\" in variable.__fields_set__:\n            self.units = variable.units\n\n        self.controller = controller\n\n    def poll(self) -&gt; Tuple[np.ndarray]:\n\"\"\"\n        Collects image data via appropriate protocol and returns time and data.\n\n        \"\"\"\n        t = datetime.now()\n\n        v = self.controller.get_value(self.varname)\n\n        self.time = np.append(self.time, t)\n        self.data = np.append(self.data, v)\n\n        return self.time, self.data\n\n    def reset(self) -&gt; None:\n        self.time = np.array([])\n        self.data = np.array([])\n</code></pre>"},{"location":"Monitors/#lume_epics.client.monitors.PVTimeSeries.__init__","title":"<code>__init__(variable, controller)</code>","text":"<p>Initializes monitor attributes.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>ScalarVariable</code> <p>Variable to monitor for time series</p> required <code>controller</code> <code>Controller</code> <p>Controller object for accessing process variable.</p> required Source code in <code>lume_epics/client/monitors.py</code> <pre><code>def __init__(self, variable: ScalarVariable, controller: Controller,) -&gt; None:\n\"\"\"Initializes monitor attributes.\n\n    Args:\n        variable (ScalarVariable): Variable to monitor for time series\n\n        controller (Controller): Controller object for accessing process variable.\n\n    \"\"\"\n    self.varname = variable.name\n    self.tstart = time.time()\n    self.time = np.array([])\n    self.data = np.array([])\n\n    self.units = None\n    # check if units has been set\n    if \"units\" in variable.__fields_set__:\n        self.units = variable.units\n\n    self.controller = controller\n</code></pre>"},{"location":"Monitors/#lume_epics.client.monitors.PVTimeSeries.poll","title":"<code>poll()</code>","text":"<p>Collects image data via appropriate protocol and returns time and data.</p> Source code in <code>lume_epics/client/monitors.py</code> <pre><code>def poll(self) -&gt; Tuple[np.ndarray]:\n\"\"\"\n    Collects image data via appropriate protocol and returns time and data.\n\n    \"\"\"\n    t = datetime.now()\n\n    v = self.controller.get_value(self.varname)\n\n    self.time = np.append(self.time, t)\n    self.data = np.append(self.data, v)\n\n    return self.time, self.data\n</code></pre>"},{"location":"Server/","title":"EPICS Server","text":"<p>The lume-epics server synchronizes process variables over Channel Access and pvAccess servers. Updates to input process variables are queued for model execution and the model output is queued for updates over both protocols. </p> <p></p>"},{"location":"Server/#lume_epics.epics_server.Server","title":"<code>Server</code>","text":"<p>Server for EPICS process variables. Can be optionally initialized with only pvAccess or Channel Access protocols.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>BaseModel</code> <p>Instantiated model</p> <code>input_variables</code> <code>Dict[str</code> <p>InputVariable]): Model input variables</p> <code>output_variables</code> <code>Dict[str</code> <p>OutputVariable]): Model output variables</p> <code>epics_config</code> <code>Optional[Dict]</code> <p>...</p> <code>_pva_fields</code> <code>List[str]</code> <p>List of variables pointing to pvAccess fields</p> <code>_protocols</code> <code>List[str]</code> <p>List of protocols in use</p> <code>in_queue</code> <code>multiprocessing.Queue</code> <code>out_queues</code> <code>Dict[str, multiprocessing.Queue]</code> <p>Queue updates to output variables to protocol servers.</p> <code>exit_event</code> <code>multiprocessing.Event</code> <p>Event triggering shutdown</p> <code>_running_indicator</code> <code>multiprocessing.Value</code> <p>Value indicating whether server is running</p> <code>_process_exit_events</code> <code>List[multiprocessing.Event]</code> <p>Exit events for each process</p> <code>_model_exec_exit_event</code> <code>Event</code> <p>Thread event for model execution exceptions</p> <code>comm_thread</code> <code>Thread</code> <p>Thread for model execution</p> <code>ca_process</code> <code>multiprocessing.Process</code> <p>Channel access server process</p> <code>pva_process</code> <code>multiprocessing.Process</code> <p>pvAccess server process</p> Source code in <code>lume_epics/epics_server.py</code> <pre><code>class Server:\n\"\"\"\n    Server for EPICS process variables. Can be optionally initialized with only\n    pvAccess or Channel Access protocols.\n\n    Attributes:\n        model (BaseModel): Instantiated model\n\n        input_variables (Dict[str: InputVariable]): Model input variables\n\n        output_variables (Dict[str: OutputVariable]): Model output variables\n\n        epics_config (Optional[Dict]): ...\n\n        _pva_fields (List[str]): List of variables pointing to pvAccess fields\n\n        _protocols (List[str]): List of protocols in use\n\n        in_queue (multiprocessing.Queue):\n\n        out_queues (Dict[str, multiprocessing.Queue]): Queue updates to output\n            variables to protocol servers.\n\n        exit_event (multiprocessing.Event): Event triggering shutdown\n\n        _running_indicator (multiprocessing.Value): Value indicating whether server is running\n\n        _process_exit_events (List[multiprocessing.Event]): Exit events for each process\n\n        _model_exec_exit_event (Event): Thread event for model execution exceptions\n\n        comm_thread (Thread): Thread for model execution\n\n        ca_process (multiprocessing.Process): Channel access server process\n\n        pva_process (multiprocessing.Process): pvAccess server process\n\n    \"\"\"\n\n    def __init__(\n        self,\n        model_class: Type[BaseModel],\n        epics_config: dict,\n        model_kwargs: dict = {},  # TODO DROP and use instantiated mode\n        epics_env: dict = {},  # TODO drop hashable default. Should be Optional[dict]\n    ) -&gt; None:\n\"\"\"Create model_class instance and configure both Channel Access and pvAccess\n        servers for execution.\n\n        Args:\n            model_class (Type[BaseModel]): Model class to be instantiated\n\n            epics_config (dict): Dictionary describing EPICS configuration for model\n                variables.\n\n            model_kwargs (dict): Kwargs to instantiate model.\n\n            epics_env (dict): Environment variables for EPICS configuration.\n\n        \"\"\"\n\n        # Update epics environment if programatically set\n        for var in EPICS_ENV_VARS:\n            if epics_env.get(var):\n                os.environ[var] = epics_env[var]\n\n        self.model = model_class(**model_kwargs)\n        self.input_variables = self.model.input_variables\n        self.output_variables = self.model.output_variables\n\n        self._epics_config = epics_config\n\n        # define programatic access to model summary\n        self._pvname = None\n        self._owner = None\n        self._date_published = None\n        self._description = None\n        self._id = None\n\n        # If configured, set up summary pv\n        if \"summary\" in self._epics_config:\n            self._pvname = self._epics_config[\"summary\"].get(\"pvname\")\n            self._owner = self._epics_config[\"summary\"].get(\"owner\", \"\")\n            self._date_published = self._epics_config[\"summary\"].get(\n                \"date_published\", \"\"\n            )\n            self._description = self._epics_config[\"summary\"].get(\"description\", \"\")\n            self._id = self._epics_config[\"summary\"].get(\"id\", \"\")\n\n        self._protocols = []\n\n        ca_config = {\n            var: self._epics_config[var]\n            for var in self._epics_config\n            if self._epics_config[var].get(\"protocol\") in [\"ca\", \"both\"]\n        }\n        pva_config = {\n            var: self._epics_config[var]\n            for var in self._epics_config\n            if self._epics_config[var].get(\"protocol\") in [\"pva\", \"both\"]\n            or var == \"summary\"\n        }\n\n        # track nested fields\n        self._pva_fields = []\n        for var, config in self._epics_config.items():\n            if config.get(\"fields\"):\n                self._pva_fields += config[\"fields\"]\n\n        if len(ca_config) &gt; 0:\n            self._protocols.append(\"ca\")\n\n        if len(pva_config) &gt; 0:\n            self._protocols.append(\"pva\")\n\n        # set up protocol based queues\n        self.in_queue = multiprocessing.Queue()\n        self.out_queues = dict()\n        for protocol in self._protocols:\n            self.out_queues[protocol] = multiprocessing.Queue()\n\n        # exit event for triggering shutdown\n        self.exit_event = multiprocessing.Event()\n        self._running_indicator = multiprocessing.Value(\"b\", False)\n        self._process_exit_events = []\n\n        # event for shutdown on model execution exceptions\n        self._model_exec_exit_event = Event()\n\n        # we use the running marker to make sure pvs + ca don't just keep adding queue elements\n        self.comm_thread = Thread(\n            target=self.run_comm_thread,\n            kwargs={\n                \"in_queue\": self.in_queue,\n                \"out_queues\": self.out_queues,\n                \"running_indicator\": self._running_indicator,\n            },\n        )\n\n        # initialize channel access server\n        if \"ca\" in self._protocols:\n            ca_input_vars = {\n                var_name: var\n                for var_name, var in self.model.input_variables.items()\n                if var_name in ca_config\n            }\n            ca_output_vars = {\n                var_name: var\n                for var_name, var in self.model.output_variables.items()\n                if var_name in ca_config\n            }\n\n            self.ca_process = CAServer(\n                input_variables=ca_input_vars,\n                output_variables=ca_output_vars,\n                epics_config=ca_config,\n                in_queue=self.in_queue,\n                out_queue=self.out_queues[\"ca\"],\n                running_indicator=self._running_indicator,\n            )\n\n            self._process_exit_events.append(self.ca_process.exit_event)\n\n        # initialize pvAccess server\n        if \"pva\" in self._protocols:\n            pva_input_vars = {\n                var_name: var\n                for var_name, var in self.input_variables.items()\n                if var_name in pva_config\n            }\n            pva_output_vars = {\n                var_name: var\n                for var_name, var in self.output_variables.items()\n                if var_name in pva_config\n            }\n\n            self.pva_process = PVAServer(\n                input_variables=pva_input_vars,\n                output_variables=pva_output_vars,\n                epics_config=pva_config,\n                in_queue=self.in_queue,\n                out_queue=self.out_queues[\"pva\"],\n                running_indicator=self._running_indicator,\n            )\n\n            self._process_exit_events.append(self.pva_process.exit_event)\n\n    def __enter__(self):\n\"\"\"Handle server startup\"\"\"\n        self.start(monitor=False)\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n\"\"\"Handle server shutdown\"\"\"\n        self.stop()\n\n    def run_comm_thread(\n        self,\n        *,\n        running_indicator: multiprocessing.Value,\n        in_queue: Optional[multiprocessing.Queue],\n        out_queues: Optional[Dict[str, multiprocessing.Queue]],\n    ):\n\"\"\"Handles communications between pvAccess server, Channel Access server, and\n             dmodel.\n\n        Arguments:\n            running_indicator (multiprocessing.Value): Indicates whether main server\n                process active.\n\n            in_queue (Optional[multiprocessing.Queue]): Queue receiving input variable\n                inputs.\n\n            out_queues (Optional[Dict[str, multiprocessing.Queue]]): Queue for communicating\n                output vars with servers.\n\n        \"\"\"\n        model = self.model\n        inputs_initialized = 0\n\n        while not self.exit_event.is_set():\n            try:\n                data = in_queue.get(timeout=0.1)\n\n                # mark running\n                running_indicator.value = True\n\n                for var in data[\"vars\"]:\n                    self.input_variables[var] = data[\"vars\"][var]\n\n                # check no input values are None\n                if not any(\n                    [var.value is None for var in self.input_variables.values()]\n                ):\n                    inputs_initialized = 1\n\n                # update output variable state\n                if inputs_initialized:\n\n                    # sync pva/ca if duplicated\n                    for protocol, queue in out_queues.items():\n                        if protocol != data[\"protocol\"]:\n                            inputs = {\n                                var: self.input_variables[var]\n                                for var in data[\"vars\"]\n                                if self._epics_config[var][\"protocol\"]\n                                in [protocol, \"both\"]\n                            }\n\n                            if len(inputs):\n                                queue.put({\"input_variables\": inputs})\n\n                    model_input = self.input_variables\n\n                    try:\n                        predicted_output = model.evaluate(model_input)\n\n                        for protocol, queue in out_queues.items():\n                            outputs = {\n                                var.name: var\n                                for var in predicted_output.values()\n                                if var.name in self._pva_fields\n                                or self._epics_config[var.name][\"protocol\"]\n                                in [protocol, \"both\"]\n                            }\n                            queue.put({\"output_variables\": outputs}, timeout=0.1)\n\n                    except Exception as e:\n                        traceback.print_exc()\n                        self._model_exec_exit_event.set()\n\n                running_indicator.value = False\n\n            except Empty:\n                continue\n\n            except Full:\n                logger.error(f\"{protocol} queue is full.\")\n\n        logger.info(\"Stopping execution thread\")\n\n    def start(self, monitor: bool = True) -&gt; None:\n\"\"\"Starts server using set server protocol(s).\n\n        Args:\n            monitor (bool): Indicates whether to run the server in the background or to\n                continually monitor. If monitor = False, the server must be explicitly\n                stopped using server.stop()\n\n        \"\"\"\n        self.comm_thread.start()\n\n        if \"ca\" in self._protocols:\n            self.ca_process.start()\n\n        if \"pva\" in self._protocols:\n            self.pva_process.start()\n\n        if monitor:\n            try:\n                while not any(\n                    [\n                        exit_event.is_set()\n                        for exit_event in self._process_exit_events\n                        + [self._model_exec_exit_event]\n                    ]\n                ):\n                    time.sleep(0.1)\n\n                # shut down server if process exited.\n                self.stop()\n\n            except KeyboardInterrupt:\n                self.stop()\n\n    def stop(self) -&gt; None:\n\"\"\"Stops the server.\"\"\"\n        logger.info(\"Stopping server.\")\n        self.exit_event.set()\n        self.comm_thread.join()\n\n        if \"ca\" in self._protocols:\n            self.ca_process.shutdown()\n\n        if \"pva\" in self._protocols:\n            self.pva_process.shutdown()\n\n        logger.info(\"Server is stopped.\")\n\n    @property\n    def summary(self):\n        return {\n            \"pvname\": self._pvname,\n            \"owner\": self._owner,\n            \"date published\": self._date_published,\n            \"description\": self._description,\n            \"id\": self._id,\n        }\n\n    @property\n    def owner(self):\n        return self._owner\n\n    @property\n    def summary_pvname(self):\n        return self._pvname\n\n    @property\n    def date_published(self):\n        return self._date_published\n\n    @property\n    def description(self):\n        return self._description\n\n    @property\n    def id(self):\n        return self._id\n</code></pre>"},{"location":"Server/#lume_epics.epics_server.Server.__enter__","title":"<code>__enter__()</code>","text":"<p>Handle server startup</p> Source code in <code>lume_epics/epics_server.py</code> <pre><code>def __enter__(self):\n\"\"\"Handle server startup\"\"\"\n    self.start(monitor=False)\n    return self\n</code></pre>"},{"location":"Server/#lume_epics.epics_server.Server.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Handle server shutdown</p> Source code in <code>lume_epics/epics_server.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n\"\"\"Handle server shutdown\"\"\"\n    self.stop()\n</code></pre>"},{"location":"Server/#lume_epics.epics_server.Server.__init__","title":"<code>__init__(model_class, epics_config, model_kwargs={}, epics_env={})</code>","text":"<p>Create model_class instance and configure both Channel Access and pvAccess servers for execution.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>Type[BaseModel]</code> <p>Model class to be instantiated</p> required <code>epics_config</code> <code>dict</code> <p>Dictionary describing EPICS configuration for model variables.</p> required <code>model_kwargs</code> <code>dict</code> <p>Kwargs to instantiate model.</p> <code>{}</code> <code>epics_env</code> <code>dict</code> <p>Environment variables for EPICS configuration.</p> <code>{}</code> Source code in <code>lume_epics/epics_server.py</code> <pre><code>def __init__(\n    self,\n    model_class: Type[BaseModel],\n    epics_config: dict,\n    model_kwargs: dict = {},  # TODO DROP and use instantiated mode\n    epics_env: dict = {},  # TODO drop hashable default. Should be Optional[dict]\n) -&gt; None:\n\"\"\"Create model_class instance and configure both Channel Access and pvAccess\n    servers for execution.\n\n    Args:\n        model_class (Type[BaseModel]): Model class to be instantiated\n\n        epics_config (dict): Dictionary describing EPICS configuration for model\n            variables.\n\n        model_kwargs (dict): Kwargs to instantiate model.\n\n        epics_env (dict): Environment variables for EPICS configuration.\n\n    \"\"\"\n\n    # Update epics environment if programatically set\n    for var in EPICS_ENV_VARS:\n        if epics_env.get(var):\n            os.environ[var] = epics_env[var]\n\n    self.model = model_class(**model_kwargs)\n    self.input_variables = self.model.input_variables\n    self.output_variables = self.model.output_variables\n\n    self._epics_config = epics_config\n\n    # define programatic access to model summary\n    self._pvname = None\n    self._owner = None\n    self._date_published = None\n    self._description = None\n    self._id = None\n\n    # If configured, set up summary pv\n    if \"summary\" in self._epics_config:\n        self._pvname = self._epics_config[\"summary\"].get(\"pvname\")\n        self._owner = self._epics_config[\"summary\"].get(\"owner\", \"\")\n        self._date_published = self._epics_config[\"summary\"].get(\n            \"date_published\", \"\"\n        )\n        self._description = self._epics_config[\"summary\"].get(\"description\", \"\")\n        self._id = self._epics_config[\"summary\"].get(\"id\", \"\")\n\n    self._protocols = []\n\n    ca_config = {\n        var: self._epics_config[var]\n        for var in self._epics_config\n        if self._epics_config[var].get(\"protocol\") in [\"ca\", \"both\"]\n    }\n    pva_config = {\n        var: self._epics_config[var]\n        for var in self._epics_config\n        if self._epics_config[var].get(\"protocol\") in [\"pva\", \"both\"]\n        or var == \"summary\"\n    }\n\n    # track nested fields\n    self._pva_fields = []\n    for var, config in self._epics_config.items():\n        if config.get(\"fields\"):\n            self._pva_fields += config[\"fields\"]\n\n    if len(ca_config) &gt; 0:\n        self._protocols.append(\"ca\")\n\n    if len(pva_config) &gt; 0:\n        self._protocols.append(\"pva\")\n\n    # set up protocol based queues\n    self.in_queue = multiprocessing.Queue()\n    self.out_queues = dict()\n    for protocol in self._protocols:\n        self.out_queues[protocol] = multiprocessing.Queue()\n\n    # exit event for triggering shutdown\n    self.exit_event = multiprocessing.Event()\n    self._running_indicator = multiprocessing.Value(\"b\", False)\n    self._process_exit_events = []\n\n    # event for shutdown on model execution exceptions\n    self._model_exec_exit_event = Event()\n\n    # we use the running marker to make sure pvs + ca don't just keep adding queue elements\n    self.comm_thread = Thread(\n        target=self.run_comm_thread,\n        kwargs={\n            \"in_queue\": self.in_queue,\n            \"out_queues\": self.out_queues,\n            \"running_indicator\": self._running_indicator,\n        },\n    )\n\n    # initialize channel access server\n    if \"ca\" in self._protocols:\n        ca_input_vars = {\n            var_name: var\n            for var_name, var in self.model.input_variables.items()\n            if var_name in ca_config\n        }\n        ca_output_vars = {\n            var_name: var\n            for var_name, var in self.model.output_variables.items()\n            if var_name in ca_config\n        }\n\n        self.ca_process = CAServer(\n            input_variables=ca_input_vars,\n            output_variables=ca_output_vars,\n            epics_config=ca_config,\n            in_queue=self.in_queue,\n            out_queue=self.out_queues[\"ca\"],\n            running_indicator=self._running_indicator,\n        )\n\n        self._process_exit_events.append(self.ca_process.exit_event)\n\n    # initialize pvAccess server\n    if \"pva\" in self._protocols:\n        pva_input_vars = {\n            var_name: var\n            for var_name, var in self.input_variables.items()\n            if var_name in pva_config\n        }\n        pva_output_vars = {\n            var_name: var\n            for var_name, var in self.output_variables.items()\n            if var_name in pva_config\n        }\n\n        self.pva_process = PVAServer(\n            input_variables=pva_input_vars,\n            output_variables=pva_output_vars,\n            epics_config=pva_config,\n            in_queue=self.in_queue,\n            out_queue=self.out_queues[\"pva\"],\n            running_indicator=self._running_indicator,\n        )\n\n        self._process_exit_events.append(self.pva_process.exit_event)\n</code></pre>"},{"location":"Server/#lume_epics.epics_server.Server.run_comm_thread","title":"<code>run_comm_thread(*, running_indicator, in_queue, out_queues)</code>","text":"<p>Handles communications between pvAccess server, Channel Access server, and      dmodel.</p> <p>Parameters:</p> Name Type Description Default <code>running_indicator</code> <code>multiprocessing.Value</code> <p>Indicates whether main server process active.</p> required <code>in_queue</code> <code>Optional[multiprocessing.Queue]</code> <p>Queue receiving input variable inputs.</p> required <code>out_queues</code> <code>Optional[Dict[str, multiprocessing.Queue]]</code> <p>Queue for communicating output vars with servers.</p> required Source code in <code>lume_epics/epics_server.py</code> <pre><code>def run_comm_thread(\n    self,\n    *,\n    running_indicator: multiprocessing.Value,\n    in_queue: Optional[multiprocessing.Queue],\n    out_queues: Optional[Dict[str, multiprocessing.Queue]],\n):\n\"\"\"Handles communications between pvAccess server, Channel Access server, and\n         dmodel.\n\n    Arguments:\n        running_indicator (multiprocessing.Value): Indicates whether main server\n            process active.\n\n        in_queue (Optional[multiprocessing.Queue]): Queue receiving input variable\n            inputs.\n\n        out_queues (Optional[Dict[str, multiprocessing.Queue]]): Queue for communicating\n            output vars with servers.\n\n    \"\"\"\n    model = self.model\n    inputs_initialized = 0\n\n    while not self.exit_event.is_set():\n        try:\n            data = in_queue.get(timeout=0.1)\n\n            # mark running\n            running_indicator.value = True\n\n            for var in data[\"vars\"]:\n                self.input_variables[var] = data[\"vars\"][var]\n\n            # check no input values are None\n            if not any(\n                [var.value is None for var in self.input_variables.values()]\n            ):\n                inputs_initialized = 1\n\n            # update output variable state\n            if inputs_initialized:\n\n                # sync pva/ca if duplicated\n                for protocol, queue in out_queues.items():\n                    if protocol != data[\"protocol\"]:\n                        inputs = {\n                            var: self.input_variables[var]\n                            for var in data[\"vars\"]\n                            if self._epics_config[var][\"protocol\"]\n                            in [protocol, \"both\"]\n                        }\n\n                        if len(inputs):\n                            queue.put({\"input_variables\": inputs})\n\n                model_input = self.input_variables\n\n                try:\n                    predicted_output = model.evaluate(model_input)\n\n                    for protocol, queue in out_queues.items():\n                        outputs = {\n                            var.name: var\n                            for var in predicted_output.values()\n                            if var.name in self._pva_fields\n                            or self._epics_config[var.name][\"protocol\"]\n                            in [protocol, \"both\"]\n                        }\n                        queue.put({\"output_variables\": outputs}, timeout=0.1)\n\n                except Exception as e:\n                    traceback.print_exc()\n                    self._model_exec_exit_event.set()\n\n            running_indicator.value = False\n\n        except Empty:\n            continue\n\n        except Full:\n            logger.error(f\"{protocol} queue is full.\")\n\n    logger.info(\"Stopping execution thread\")\n</code></pre>"},{"location":"Server/#lume_epics.epics_server.Server.start","title":"<code>start(monitor=True)</code>","text":"<p>Starts server using set server protocol(s).</p> <p>Parameters:</p> Name Type Description Default <code>monitor</code> <code>bool</code> <p>Indicates whether to run the server in the background or to continually monitor. If monitor = False, the server must be explicitly stopped using server.stop()</p> <code>True</code> Source code in <code>lume_epics/epics_server.py</code> <pre><code>def start(self, monitor: bool = True) -&gt; None:\n\"\"\"Starts server using set server protocol(s).\n\n    Args:\n        monitor (bool): Indicates whether to run the server in the background or to\n            continually monitor. If monitor = False, the server must be explicitly\n            stopped using server.stop()\n\n    \"\"\"\n    self.comm_thread.start()\n\n    if \"ca\" in self._protocols:\n        self.ca_process.start()\n\n    if \"pva\" in self._protocols:\n        self.pva_process.start()\n\n    if monitor:\n        try:\n            while not any(\n                [\n                    exit_event.is_set()\n                    for exit_event in self._process_exit_events\n                    + [self._model_exec_exit_event]\n                ]\n            ):\n                time.sleep(0.1)\n\n            # shut down server if process exited.\n            self.stop()\n\n        except KeyboardInterrupt:\n            self.stop()\n</code></pre>"},{"location":"Server/#lume_epics.epics_server.Server.stop","title":"<code>stop()</code>","text":"<p>Stops the server.</p> Source code in <code>lume_epics/epics_server.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stops the server.\"\"\"\n    logger.info(\"Stopping server.\")\n    self.exit_event.set()\n    self.comm_thread.join()\n\n    if \"ca\" in self._protocols:\n        self.ca_process.shutdown()\n\n    if \"pva\" in self._protocols:\n        self.pva_process.shutdown()\n\n    logger.info(\"Server is stopped.\")\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CADriver","title":"<code>CADriver</code>","text":"<p>         Bases: <code>Driver</code></p> <p>Class for handling read and write requests to Channel Access process variables.</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>class CADriver(Driver):\n\"\"\"\n    Class for handling read and write requests to Channel Access process variables.\n    \"\"\"\n\n    def __init__(self, server) -&gt; None:\n\"\"\"Initialize the Channel Access driver. Store input state and output state.\"\"\"\n        super(CADriver, self).__init__()\n        self.server = server\n\n    def read(self, pvname: str) -&gt; Union[float, np.ndarray]:\n\"\"\"Method executed by server when clients read a Channel Access process\n        variable.\n\n        Args:\n            pvname (str): Process variable name.\n\n        \"\"\"\n        return self.getParam(pvname)\n\n    def write(self, pvname: str, value: Union[float, np.ndarray]) -&gt; bool:\n\"\"\"Method executed by server when clients write to a Channel Access process\n        variable.\n\n\n        Args:\n            pvname (str): Process variable name.\n\n            value (Union[float, np.ndarray]): Value to assign to the process variable.\n\n        \"\"\"\n\n        # handle area detector types\n        model_var_name = self.server._pvname_to_varname_map.get(pvname)\n\n        if pvname in self.server._child_to_parent_map:\n            model_var_name = self.server._child_to_parent_map[pvname]\n\n        if model_var_name in self.server._output_variables:\n            logger.warning(\n                \"Cannot update variable %s. Output variables can only be updated via surrogate model callback.\",\n                pvname,\n            )\n            return False\n\n        if value is None:\n            logger.debug(f\"None value provided for {pvname}\")\n            return False\n\n        if model_var_name in self.server._input_variables:\n\n            if self.server._input_variables[model_var_name].is_constant:\n                logger.debug(\"Unable to update constant variable %s\", model_var_name)\n\n            else:\n                self.setParam(pvname, value)\n                self.updatePVs()\n                logger.debug(\n                    \"Channel Access process variable %s updated with value %s\",\n                    pvname,\n                    value,\n                )\n\n                self.server.update_pv(pvname=pvname, value=value)\n                return True\n\n        else:\n            logger.error(\"%s not found in server variables.\", pvname)\n            return False\n\n    def update_pvs(self, variables: List[Variable]) -&gt; None:\n\"\"\"Update output Channel Access process variables after model execution.\n\n        Args:\n            variables (List[Variable]): List of variables.\n        \"\"\"\n        for variable in variables:\n            pvname = self.server._varname_to_pvname_map[variable.name]\n            if variable.name in self.server._input_variables and variable.is_constant:\n                logger.debug(\n                    \"Cannot update constant variable %s, %s\", variable.name, pvname\n                )\n\n            else:\n                if variable.variable_type == \"image\":\n                    logger.debug(\n                        \"Channel Access image process variable %s updated.\",\n                        pvname,\n                    )\n                    self.setParam(pvname + \":ArrayData_RBV\", variable.value.flatten())\n                    self.setParam(pvname + \":MinX_RBV\", variable.x_min)\n                    self.setParam(pvname + \":MinY_RBV\", variable.y_min)\n                    self.setParam(pvname + \":MaxX_RBV\", variable.x_max)\n                    self.setParam(pvname + \":MaxY_RBV\", variable.y_max)\n\n                elif variable.variable_type == \"scalar\":\n                    logger.debug(\n                        \"Channel Access process variable %s updated wth value %s.\",\n                        pvname,\n                        variable.value,\n                    )\n                    self.setParam(pvname, variable.value)\n\n                elif variable.variable_type == \"array\":\n                    logger.debug(\n                        \"Channel Access image process variable %s updated.\",\n                        pvname,\n                    )\n\n                    self.setParam(pvname + \":ArrayData_RBV\", variable.value.flatten())\n\n                else:\n                    logger.debug(\n                        \"No instructions for handling variable %s of type %s\",\n                        variable.name,\n                        variable.variable_type,\n                    )\n\n        self.updatePVs()\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CADriver.__init__","title":"<code>__init__(server)</code>","text":"<p>Initialize the Channel Access driver. Store input state and output state.</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def __init__(self, server) -&gt; None:\n\"\"\"Initialize the Channel Access driver. Store input state and output state.\"\"\"\n    super(CADriver, self).__init__()\n    self.server = server\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CADriver.read","title":"<code>read(pvname)</code>","text":"<p>Method executed by server when clients read a Channel Access process variable.</p> <p>Parameters:</p> Name Type Description Default <code>pvname</code> <code>str</code> <p>Process variable name.</p> required Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def read(self, pvname: str) -&gt; Union[float, np.ndarray]:\n\"\"\"Method executed by server when clients read a Channel Access process\n    variable.\n\n    Args:\n        pvname (str): Process variable name.\n\n    \"\"\"\n    return self.getParam(pvname)\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CADriver.update_pvs","title":"<code>update_pvs(variables)</code>","text":"<p>Update output Channel Access process variables after model execution.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>List[Variable]</code> <p>List of variables.</p> required Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def update_pvs(self, variables: List[Variable]) -&gt; None:\n\"\"\"Update output Channel Access process variables after model execution.\n\n    Args:\n        variables (List[Variable]): List of variables.\n    \"\"\"\n    for variable in variables:\n        pvname = self.server._varname_to_pvname_map[variable.name]\n        if variable.name in self.server._input_variables and variable.is_constant:\n            logger.debug(\n                \"Cannot update constant variable %s, %s\", variable.name, pvname\n            )\n\n        else:\n            if variable.variable_type == \"image\":\n                logger.debug(\n                    \"Channel Access image process variable %s updated.\",\n                    pvname,\n                )\n                self.setParam(pvname + \":ArrayData_RBV\", variable.value.flatten())\n                self.setParam(pvname + \":MinX_RBV\", variable.x_min)\n                self.setParam(pvname + \":MinY_RBV\", variable.y_min)\n                self.setParam(pvname + \":MaxX_RBV\", variable.x_max)\n                self.setParam(pvname + \":MaxY_RBV\", variable.y_max)\n\n            elif variable.variable_type == \"scalar\":\n                logger.debug(\n                    \"Channel Access process variable %s updated wth value %s.\",\n                    pvname,\n                    variable.value,\n                )\n                self.setParam(pvname, variable.value)\n\n            elif variable.variable_type == \"array\":\n                logger.debug(\n                    \"Channel Access image process variable %s updated.\",\n                    pvname,\n                )\n\n                self.setParam(pvname + \":ArrayData_RBV\", variable.value.flatten())\n\n            else:\n                logger.debug(\n                    \"No instructions for handling variable %s of type %s\",\n                    variable.name,\n                    variable.variable_type,\n                )\n\n    self.updatePVs()\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CADriver.write","title":"<code>write(pvname, value)</code>","text":"<p>Method executed by server when clients write to a Channel Access process variable.</p> <p>Parameters:</p> Name Type Description Default <code>pvname</code> <code>str</code> <p>Process variable name.</p> required <code>value</code> <code>Union[float, np.ndarray]</code> <p>Value to assign to the process variable.</p> required Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def write(self, pvname: str, value: Union[float, np.ndarray]) -&gt; bool:\n\"\"\"Method executed by server when clients write to a Channel Access process\n    variable.\n\n\n    Args:\n        pvname (str): Process variable name.\n\n        value (Union[float, np.ndarray]): Value to assign to the process variable.\n\n    \"\"\"\n\n    # handle area detector types\n    model_var_name = self.server._pvname_to_varname_map.get(pvname)\n\n    if pvname in self.server._child_to_parent_map:\n        model_var_name = self.server._child_to_parent_map[pvname]\n\n    if model_var_name in self.server._output_variables:\n        logger.warning(\n            \"Cannot update variable %s. Output variables can only be updated via surrogate model callback.\",\n            pvname,\n        )\n        return False\n\n    if value is None:\n        logger.debug(f\"None value provided for {pvname}\")\n        return False\n\n    if model_var_name in self.server._input_variables:\n\n        if self.server._input_variables[model_var_name].is_constant:\n            logger.debug(\"Unable to update constant variable %s\", model_var_name)\n\n        else:\n            self.setParam(pvname, value)\n            self.updatePVs()\n            logger.debug(\n                \"Channel Access process variable %s updated with value %s\",\n                pvname,\n                value,\n            )\n\n            self.server.update_pv(pvname=pvname, value=value)\n            return True\n\n    else:\n        logger.error(\"%s not found in server variables.\", pvname)\n        return False\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServer","title":"<code>CAServer</code>","text":"<p>         Bases: <code>CAProcess</code></p> <p>Process-based implementation of Channel Access server.</p> <p>Attributes:</p> Name Type Description <code>_ca_server</code> <code>SimpleServer</code> <p>pcaspy SimpleServer instance</p> <code>_ca_driver</code> <code>Driver</code> <p>pcaspy Driver instance</p> <code>_input_variables</code> <code>Dict[str, InputVariable]</code> <p>Mapping of input variable name to variable</p> <code>_output_variables</code> <code>Dict[str, InputVariable]</code> <p>Mapping of output variable name to variable</p> <code>_server_thread</code> <code>ServerThread</code> <p>Thread for running the server</p> <code>shutdown_event</code> <code>multiprocessing.Event</code> <p>Event indicating shutdown</p> <code>exit_event</code> <code>multiprocessing.Event</code> <p>Event indicating early exit</p> <code>_running_indicator</code> <code>multiprocessing.Value</code> <p>Value indicating whether model execution ongoing</p> <code>_epics_config</code> <code>dict</code> <p>Dictionary describing EPICS configuration for model variables</p> <code>_in_queue</code> <code>multiprocessing.Queue</code> <p>Queue for pushing updated input variables to model execution</p> <code>_out_queue</code> <code>multiprocessing.Queue</code> <p>Process model output variables and sync with pvAccess server</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>class CAServer(CAProcess):\n\"\"\"\n    Process-based implementation of Channel Access server.\n\n    Attributes:\n        _ca_server (SimpleServer): pcaspy SimpleServer instance\n\n        _ca_driver (Driver): pcaspy Driver instance\n\n        _input_variables (Dict[str, InputVariable]): Mapping of input variable name to variable\n\n        _output_variables (Dict[str, InputVariable]): Mapping of output variable name to variable\n\n        _server_thread (ServerThread): Thread for running the server\n\n        shutdown_event (multiprocessing.Event): Event indicating shutdown\n\n        exit_event (multiprocessing.Event): Event indicating early exit\n\n        _running_indicator (multiprocessing.Value): Value indicating whether model execution ongoing\n\n        _epics_config (dict): Dictionary describing EPICS configuration for model variables\n\n        _in_queue (multiprocessing.Queue): Queue for pushing updated input variables to model execution\n\n        _out_queue (multiprocessing.Queue): Process model output variables and sync with pvAccess server\n\n    \"\"\"\n\n    protocol = \"ca\"\n\n    def __init__(\n        self,\n        input_variables: Dict[str, InputVariable],\n        output_variables: Dict[str, OutputVariable],\n        epics_config: dict,\n        in_queue: multiprocessing.Queue,\n        out_queue: multiprocessing.Queue,\n        running_indicator: multiprocessing.Value,\n        *args,\n        **kwargs,\n    ) -&gt; None:\n\"\"\"Initialize server process.\n\n        Args:\n            input_variables (Dict[str, InputVariable]): Dictionary mapping pvname to lume-model input variable.\n            output_variables (Dict[str, OutputVariable]):Dictionary mapping pvname to lume-model output variable.\n            epics_config (dict): Dictionary mapping pvname to EPICS configuration.\n            in_queue (multiprocessing.Queue): Queue for tracking updates to input variables.\n            out_queue (multiprocessing.Queue): Queue for tracking updates to output variables.\n            running_indicator (multiprocessing.Value): Multiprocessing value for indicating if server running.\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._ca_server = None\n        self._ca_driver = None\n        self._server_thread = None\n        self._input_variables = input_variables\n        self._output_variables = output_variables\n        self._in_queue = in_queue\n        self._out_queue = out_queue\n        self._providers = {}\n        self._running_indicator = running_indicator\n        self._epics_config = epics_config\n        self.exit_event = multiprocessing.Event()\n        self.shutdown_event = multiprocessing.Event()\n\n        # utility maps\n        self._pvname_to_varname_map = {\n            config[\"pvname\"]: var_name for var_name, config in epics_config.items()\n        }\n        self._varname_to_pvname_map = {\n            var_name: config[\"pvname\"] for var_name, config in epics_config.items()\n        }\n\n        # cached pv values\n        self._cached_values = {}\n        self._monitors = {}\n\n    def update_pv(self, pvname, value) -&gt; None:\n\"\"\"Adds update to input process variable to the input queue.\n\n        Args:\n            pvname (str): Name of process variable\n\n            value (Union[np.ndarray, float]): Value to set\n\n        \"\"\"\n        model_var_name = self._pvname_to_varname_map.get(pvname)\n        if pvname in self._child_to_parent_map:\n            model_var_name = self._child_to_parent_map[pvname]\n\n        variable = self._input_variables[model_var_name]\n\n        # check for already cached variable\n        variable = self._cached_values.get(model_var_name, variable)\n\n        # check for image variable and proper assignments\n        if variable.variable_type == \"image\":\n\n            attr_type = pvname.split(\":\")[-1]\n\n            if attr_type == \"ArrayData_RBV\":\n                value = np.array(value)\n                value = value.reshape(variable.shape)\n                variable.value = value\n\n            if attr_type == \"MinX_RBV\":\n                variable.x_min = value\n\n            if attr_type == \"MinY_RBV\":\n                variable.y_min = value\n\n            if attr_type == \"MaxX_RBV\":\n                variable.x_max = value\n\n            if attr_type == \"MaxY_RBV\":\n                variable.y_max = value\n\n        # assign value\n        else:\n            variable.value = value\n\n        self._cached_values[model_var_name] = variable\n\n        # only update if not running\n        if not self._running_indicator.value:\n            self._in_queue.put({\"protocol\": \"ca\", \"vars\": self._cached_values})\n            self._cached_values = {}\n\n    def _monitor_callback(self, pvname=None, value=None, **kwargs) -&gt; None:\n\"\"\"Callback executed on value change events.\"\"\"\n        model_var_name = self._pvname_to_varname_map.get(pvname)\n\n        variable = self._input_variables.get(model_var_name)\n        if not variable:\n            variable = self._output_variables.get(model_var_name)\n\n        # check for already cached variable\n        variable = self._cached_values.get(model_var_name, variable)\n\n        # check for image variable and proper assignments\n        if variable.variable_type == \"image\":\n\n            attr_type = pvname.split(\":\")[-1]\n\n            if attr_type == \"ArrayData_RBV\":\n                value = value.reshape(variable.shape())\n                variable.value = value\n\n            if attr_type == \"MinX_RBV\":\n                variable.x_min = value\n\n            if attr_type == \"MinY_RBV\":\n                variable.y_mix = value\n\n            if attr_type == \"MaxX_RBV\":\n                variable.x_max = value\n\n            if attr_type == \"MaxY_RBV\":\n                variable.y_max = value\n\n        # assign value\n        else:\n            variable.value = value\n\n        self._cached_values[model_var_name] = variable\n\n        # only update if not running\n        if not self._running_indicator.value:\n            self._in_queue.put({\"protocol\": \"ca\", \"vars\": self._cached_values})\n            self._cached_values = {}\n\n    def _initialize_model(self):\n\"\"\"Initialize model\"\"\"\n        self._in_queue.put({\"protocol\": \"ca\", \"vars\": self._input_variables})\n\n    def setup_server(self) -&gt; None:\n\"\"\"Configure and start server.\"\"\"\n        # ignore interrupt in subprocess\n        signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n        logger.info(\"Initializing CA server\")\n\n        # update value with stored defaults\n        for var_name in self._input_variables:\n            if self._epics_config[var_name][\"serve\"]:\n                self._input_variables[var_name].value = self._input_variables[\n                    var_name\n                ].default\n\n            else:\n                pvname = self._varname_to_pvname_map[var_name]\n                val = epics.caget(pvname)\n                if val is None:\n                    logger.error(\n                        f\"Unable to connect to {self._varname_to_pvname_map[var_name]}\"\n                    )\n                    self.exit_event.set()\n                    return False\n\n                self._input_variables[var_name].value = val\n\n        # initialize channel access server\n        self._ca_server = SimpleServer()\n\n        # update output variable values\n        self._initialize_model()\n        model_outputs = None\n        while not self.shutdown_event.is_set() and model_outputs is None:\n\n            try:\n                model_outputs = self._out_queue.get(timeout=0.1)\n            except Empty:\n                pass\n\n        if self.shutdown_event.is_set():\n            pass\n\n        model_output_vars = model_outputs.get(\"output_variables\", {})\n        self._output_variables.update(model_output_vars)\n\n        # differentiate between values to serve and not to serve\n        to_serve = []\n        external = []\n        variables = copy.deepcopy(self._input_variables)\n        variables.update(self._output_variables)\n\n        for var in variables:\n            if var in self._epics_config:\n                if self._epics_config[var][\"serve\"]:\n                    to_serve.append(var)\n\n                else:\n                    external.append(var)\n\n        # build pvdb and child to parent map for area detector scheme\n        pvdb, self._child_to_parent_map = build_pvdb(\n            [variables[var_name] for var_name in to_serve], self._epics_config\n        )\n\n        # for external variables create monitors\n        for var_name in external:\n            self._monitors[var_name] = epics.pv.get_pv(\n                self._varname_to_pvname_map[var_name]\n            )\n            self._monitors[var_name].add_callback(self._monitor_callback)\n\n        # Register pvs with server if serving\n        if len(pvdb):\n            self._ca_server.createPV(\"\", pvdb)\n\n            # set up driver for handing read and write requests to process variables\n            self._ca_driver = CADriver(server=self)\n\n            # start the server thread\n            self._server_thread = CAServerThread(self._ca_server)\n            self._server_thread.start()\n\n        logger.info(\"CA server started\")\n        return True\n\n    def update_pvs(\n        self,\n        input_variables: Dict[str, InputVariable],\n        output_variables: Dict[str, OutputVariable],\n    ) -&gt; None:\n\"\"\"Update process variables over Channel Access.\n\n        Args:\n            input_variables (Dict[str, InputVariable]): List of lume-epics output variables.\n\n            output_variables (Dict[str, OutputVariable]): List of lume-model output variables.\n\n        \"\"\"\n        variables = input_variables\n        variables.update(output_variables)\n\n        # update variables if the driver is running\n        if self._ca_driver is not None:\n            self._ca_driver.update_pvs(list(variables.values()))\n\n    def run(self) -&gt; None:\n\"\"\"Start server process.\"\"\"\n        started = self.setup_server()\n        if started:\n            while not self.shutdown_event.is_set():\n                try:\n                    data = self._out_queue.get_nowait()\n                    inputs = data.get(\"input_variables\", {})\n                    outputs = data.get(\"output_variables\", {})\n                    self.update_pvs(inputs, outputs)\n\n                except Empty:\n                    time.sleep(0.05)\n                    logger.debug(\"out queue empty\")\n\n            # if server thread running\n            if self._server_thread is not None:\n                self._server_thread.stop()\n\n            logger.info(\"Channel access server stopped.\")\n        else:\n            logger.info(\"Unable to set up server. Shutting down.\")\n\n    def shutdown(self):\n\"\"\"Safely shutdown the server process.\"\"\"\n        self.shutdown_event.set()\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServer.__init__","title":"<code>__init__(input_variables, output_variables, epics_config, in_queue, out_queue, running_indicator, *args, **kwargs)</code>","text":"<p>Initialize server process.</p> <p>Parameters:</p> Name Type Description Default <code>input_variables</code> <code>Dict[str, InputVariable]</code> <p>Dictionary mapping pvname to lume-model input variable.</p> required <code>output_variables</code> <code>Dict[str, OutputVariable]</code> <p>Dictionary mapping pvname to lume-model output variable.</p> required <code>epics_config</code> <code>dict</code> <p>Dictionary mapping pvname to EPICS configuration.</p> required <code>in_queue</code> <code>multiprocessing.Queue</code> <p>Queue for tracking updates to input variables.</p> required <code>out_queue</code> <code>multiprocessing.Queue</code> <p>Queue for tracking updates to output variables.</p> required <code>running_indicator</code> <code>multiprocessing.Value</code> <p>Multiprocessing value for indicating if server running.</p> required Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def __init__(\n    self,\n    input_variables: Dict[str, InputVariable],\n    output_variables: Dict[str, OutputVariable],\n    epics_config: dict,\n    in_queue: multiprocessing.Queue,\n    out_queue: multiprocessing.Queue,\n    running_indicator: multiprocessing.Value,\n    *args,\n    **kwargs,\n) -&gt; None:\n\"\"\"Initialize server process.\n\n    Args:\n        input_variables (Dict[str, InputVariable]): Dictionary mapping pvname to lume-model input variable.\n        output_variables (Dict[str, OutputVariable]):Dictionary mapping pvname to lume-model output variable.\n        epics_config (dict): Dictionary mapping pvname to EPICS configuration.\n        in_queue (multiprocessing.Queue): Queue for tracking updates to input variables.\n        out_queue (multiprocessing.Queue): Queue for tracking updates to output variables.\n        running_indicator (multiprocessing.Value): Multiprocessing value for indicating if server running.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._ca_server = None\n    self._ca_driver = None\n    self._server_thread = None\n    self._input_variables = input_variables\n    self._output_variables = output_variables\n    self._in_queue = in_queue\n    self._out_queue = out_queue\n    self._providers = {}\n    self._running_indicator = running_indicator\n    self._epics_config = epics_config\n    self.exit_event = multiprocessing.Event()\n    self.shutdown_event = multiprocessing.Event()\n\n    # utility maps\n    self._pvname_to_varname_map = {\n        config[\"pvname\"]: var_name for var_name, config in epics_config.items()\n    }\n    self._varname_to_pvname_map = {\n        var_name: config[\"pvname\"] for var_name, config in epics_config.items()\n    }\n\n    # cached pv values\n    self._cached_values = {}\n    self._monitors = {}\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServer.run","title":"<code>run()</code>","text":"<p>Start server process.</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"Start server process.\"\"\"\n    started = self.setup_server()\n    if started:\n        while not self.shutdown_event.is_set():\n            try:\n                data = self._out_queue.get_nowait()\n                inputs = data.get(\"input_variables\", {})\n                outputs = data.get(\"output_variables\", {})\n                self.update_pvs(inputs, outputs)\n\n            except Empty:\n                time.sleep(0.05)\n                logger.debug(\"out queue empty\")\n\n        # if server thread running\n        if self._server_thread is not None:\n            self._server_thread.stop()\n\n        logger.info(\"Channel access server stopped.\")\n    else:\n        logger.info(\"Unable to set up server. Shutting down.\")\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServer.setup_server","title":"<code>setup_server()</code>","text":"<p>Configure and start server.</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def setup_server(self) -&gt; None:\n\"\"\"Configure and start server.\"\"\"\n    # ignore interrupt in subprocess\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n    logger.info(\"Initializing CA server\")\n\n    # update value with stored defaults\n    for var_name in self._input_variables:\n        if self._epics_config[var_name][\"serve\"]:\n            self._input_variables[var_name].value = self._input_variables[\n                var_name\n            ].default\n\n        else:\n            pvname = self._varname_to_pvname_map[var_name]\n            val = epics.caget(pvname)\n            if val is None:\n                logger.error(\n                    f\"Unable to connect to {self._varname_to_pvname_map[var_name]}\"\n                )\n                self.exit_event.set()\n                return False\n\n            self._input_variables[var_name].value = val\n\n    # initialize channel access server\n    self._ca_server = SimpleServer()\n\n    # update output variable values\n    self._initialize_model()\n    model_outputs = None\n    while not self.shutdown_event.is_set() and model_outputs is None:\n\n        try:\n            model_outputs = self._out_queue.get(timeout=0.1)\n        except Empty:\n            pass\n\n    if self.shutdown_event.is_set():\n        pass\n\n    model_output_vars = model_outputs.get(\"output_variables\", {})\n    self._output_variables.update(model_output_vars)\n\n    # differentiate between values to serve and not to serve\n    to_serve = []\n    external = []\n    variables = copy.deepcopy(self._input_variables)\n    variables.update(self._output_variables)\n\n    for var in variables:\n        if var in self._epics_config:\n            if self._epics_config[var][\"serve\"]:\n                to_serve.append(var)\n\n            else:\n                external.append(var)\n\n    # build pvdb and child to parent map for area detector scheme\n    pvdb, self._child_to_parent_map = build_pvdb(\n        [variables[var_name] for var_name in to_serve], self._epics_config\n    )\n\n    # for external variables create monitors\n    for var_name in external:\n        self._monitors[var_name] = epics.pv.get_pv(\n            self._varname_to_pvname_map[var_name]\n        )\n        self._monitors[var_name].add_callback(self._monitor_callback)\n\n    # Register pvs with server if serving\n    if len(pvdb):\n        self._ca_server.createPV(\"\", pvdb)\n\n        # set up driver for handing read and write requests to process variables\n        self._ca_driver = CADriver(server=self)\n\n        # start the server thread\n        self._server_thread = CAServerThread(self._ca_server)\n        self._server_thread.start()\n\n    logger.info(\"CA server started\")\n    return True\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServer.shutdown","title":"<code>shutdown()</code>","text":"<p>Safely shutdown the server process.</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def shutdown(self):\n\"\"\"Safely shutdown the server process.\"\"\"\n    self.shutdown_event.set()\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServer.update_pv","title":"<code>update_pv(pvname, value)</code>","text":"<p>Adds update to input process variable to the input queue.</p> <p>Parameters:</p> Name Type Description Default <code>pvname</code> <code>str</code> <p>Name of process variable</p> required <code>value</code> <code>Union[np.ndarray, float]</code> <p>Value to set</p> required Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def update_pv(self, pvname, value) -&gt; None:\n\"\"\"Adds update to input process variable to the input queue.\n\n    Args:\n        pvname (str): Name of process variable\n\n        value (Union[np.ndarray, float]): Value to set\n\n    \"\"\"\n    model_var_name = self._pvname_to_varname_map.get(pvname)\n    if pvname in self._child_to_parent_map:\n        model_var_name = self._child_to_parent_map[pvname]\n\n    variable = self._input_variables[model_var_name]\n\n    # check for already cached variable\n    variable = self._cached_values.get(model_var_name, variable)\n\n    # check for image variable and proper assignments\n    if variable.variable_type == \"image\":\n\n        attr_type = pvname.split(\":\")[-1]\n\n        if attr_type == \"ArrayData_RBV\":\n            value = np.array(value)\n            value = value.reshape(variable.shape)\n            variable.value = value\n\n        if attr_type == \"MinX_RBV\":\n            variable.x_min = value\n\n        if attr_type == \"MinY_RBV\":\n            variable.y_min = value\n\n        if attr_type == \"MaxX_RBV\":\n            variable.x_max = value\n\n        if attr_type == \"MaxY_RBV\":\n            variable.y_max = value\n\n    # assign value\n    else:\n        variable.value = value\n\n    self._cached_values[model_var_name] = variable\n\n    # only update if not running\n    if not self._running_indicator.value:\n        self._in_queue.put({\"protocol\": \"ca\", \"vars\": self._cached_values})\n        self._cached_values = {}\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServer.update_pvs","title":"<code>update_pvs(input_variables, output_variables)</code>","text":"<p>Update process variables over Channel Access.</p> <p>Parameters:</p> Name Type Description Default <code>input_variables</code> <code>Dict[str, InputVariable]</code> <p>List of lume-epics output variables.</p> required <code>output_variables</code> <code>Dict[str, OutputVariable]</code> <p>List of lume-model output variables.</p> required Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def update_pvs(\n    self,\n    input_variables: Dict[str, InputVariable],\n    output_variables: Dict[str, OutputVariable],\n) -&gt; None:\n\"\"\"Update process variables over Channel Access.\n\n    Args:\n        input_variables (Dict[str, InputVariable]): List of lume-epics output variables.\n\n        output_variables (Dict[str, OutputVariable]): List of lume-model output variables.\n\n    \"\"\"\n    variables = input_variables\n    variables.update(output_variables)\n\n    # update variables if the driver is running\n    if self._ca_driver is not None:\n        self._ca_driver.update_pvs(list(variables.values()))\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServerThread","title":"<code>CAServerThread</code>","text":"<p>         Bases: <code>CAThread</code></p> <p>A helper class to run server in a thread.</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>class CAServerThread(CAThread):\n\"\"\"\n    A helper class to run server in a thread.\n    \"\"\"\n\n    def __init__(self, server):\n\"\"\"\n\n        Args:\n            server (pcaspy.SimpleServer): Pcaspy server to run in thread.\n        \"\"\"\n        super(CAThread, self).__init__()\n        self.server = server\n        self.running = True\n\n    def run(self):\n\"\"\"\n        Start the server processing\n        \"\"\"\n        while self.running:\n            self.server.process(0.1)\n\n    def stop(self):\n\"\"\"\n        Stop the server processing\n        \"\"\"\n        self.running = False\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServerThread.__init__","title":"<code>__init__(server)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>server</code> <code>pcaspy.SimpleServer</code> <p>Pcaspy server to run in thread.</p> required Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def __init__(self, server):\n\"\"\"\n\n    Args:\n        server (pcaspy.SimpleServer): Pcaspy server to run in thread.\n    \"\"\"\n    super(CAThread, self).__init__()\n    self.server = server\n    self.running = True\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServerThread.run","title":"<code>run()</code>","text":"<p>Start the server processing</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def run(self):\n\"\"\"\n    Start the server processing\n    \"\"\"\n    while self.running:\n        self.server.process(0.1)\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.CAServerThread.stop","title":"<code>stop()</code>","text":"<p>Stop the server processing</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def stop(self):\n\"\"\"\n    Stop the server processing\n    \"\"\"\n    self.running = False\n</code></pre>"},{"location":"Server/#lume_epics.epics_ca_server.build_pvdb","title":"<code>build_pvdb(variables, epics_config)</code>","text":"<p>Utility function for building dictionary (pvdb) used to initialize the channel access server.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>List[Variable]</code> <p>List of lume_model variables to be served with channel access server.</p> required <code>epics_config</code> <code>dict</code> <p>Epics pvnames for each variable</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>pvdb (dict)</p> <code>child_to_parent_map</code> <code>dict</code> <p>Mapping of child pvs to parent model variables</p> Source code in <code>lume_epics/epics_ca_server.py</code> <pre><code>def build_pvdb(variables: List[Variable], epics_config: dict) -&gt; tuple:\n\"\"\"Utility function for building dictionary (pvdb) used to initialize the channel\n    access server.\n\n    Args:\n        variables (List[Variable]): List of lume_model variables to be served with\n            channel access server.\n\n        epics_config (dict): Epics pvnames for each variable\n\n    Returns:\n        pvdb (dict)\n        child_to_parent_map (dict): Mapping of child pvs to parent model variables\n\n    \"\"\"\n    pvdb = {}\n    child_to_parent_map = {}\n\n    for variable in variables:\n        pvname = epics_config.get(variable.name)[\"pvname\"]\n\n        if variable.variable_type == \"image\":\n\n            if variable.value is None:\n                ndim = np.nan\n                shape = np.nan\n                array_size_x = np.nan\n                array_size_y = np.nan\n                array_size = np.nan\n                array_data = np.nan\n                count = np.nan\n\n            else:\n                ndim = variable.value.ndim\n                shape = variable.value.shape\n                array_size_x = variable.value.shape[0]\n                array_size_y = variable.value.shape[1]\n                array_size = int(np.prod(variable.value.shape))\n                array_data = variable.value.flatten()\n                count = int(np.prod(variable.value.shape))\n\n            # infer color mode\n            if ndim == 2:\n                color_mode = 0\n\n            elif ndim == 3:\n                color_mode = 1\n\n            else:\n                logger.info(\"Color mode cannot be inferred from image shape %s.\", ndim)\n                color_mode = np.nan\n\n            # assign default PVS\n            pvdb.update(\n                {\n                    f\"{pvname}:NDimensions_RBV\": {\n                        \"type\": \"float\",\n                        \"prec\": variable.precision,\n                        \"value\": ndim,\n                    },\n                    f\"{pvname}:Dimensions_RBV\": {\n                        \"type\": \"int\",\n                        \"prec\": variable.precision,\n                        \"count\": ndim,\n                        \"value\": shape,\n                    },\n                    f\"{pvname}:ArraySizeX_RBV\": {\n                        \"type\": \"int\",\n                        \"value\": array_size_x,\n                    },\n                    f\"{pvname}:ArraySizeY_RBV\": {\n                        \"type\": \"int\",\n                        \"value\": array_size_y,\n                    },\n                    f\"{pvname}:ArraySize_RBV\": {\n                        \"type\": \"int\",\n                        \"value\": array_size,\n                    },\n                    f\"{pvname}:ArrayData_RBV\": {\n                        \"type\": \"float\",\n                        \"prec\": variable.precision,\n                        \"count\": count,\n                        \"value\": array_data,\n                    },\n                    f\"{pvname}:MinX_RBV\": {\n                        \"type\": \"float\",\n                        \"value\": variable.x_min,\n                    },\n                    f\"{pvname}:MinY_RBV\": {\n                        \"type\": \"float\",\n                        \"value\": variable.y_min,\n                    },\n                    f\"{pvname}:MaxX_RBV\": {\n                        \"type\": \"float\",\n                        \"value\": variable.x_max,\n                    },\n                    f\"{pvname}:MaxY_RBV\": {\n                        \"type\": \"float\",\n                        \"value\": variable.y_max,\n                    },\n                    f\"{pvname}:ColorMode_RBV\": {\n                        \"type\": \"int\",\n                        \"value\": color_mode,\n                    },\n                }\n            )\n\n            child_to_parent_map.update(\n                {\n                    f\"{pvname}:{child}\": variable.name\n                    for child in [\n                        \"NDimensions_RBV\",\n                        \"Dimensions_RBV\",\n                        \"ArraySizeX_RBV\",\n                        \"ArraySizeY_RBV\",\n                        \"ArraySize_RBV\",\n                        \"ArrayData_RBV\",\n                        \"MinX_RBV\",\n                        \"MinY_RBV\",\n                        \"MaxX_RBV\",\n                        \"MaxY_RBV\",\n                        \"ColorMode_RBV\",\n                    ]\n                }\n            )\n\n            if \"units\" in variable.__fields_set__:\n                pvdb[f\"{pvname}:ArrayData_RBV\"][\"unit\"] = variable.units\n\n            # handle rgb arrays\n            if ndim &gt; 2:\n                pvdb[f\"{pvname}:ArraySizeZ_RBV\"] = {\n                    \"type\": \"int\",\n                    \"value\": variable.value.shape[2],\n                }\n\n        elif variable.variable_type == \"scalar\":\n            pvdb[pvname] = variable.dict(exclude_unset=True, by_alias=True)\n            if variable.value_range is not None:\n                pvdb[pvname][\"hilim\"] = variable.value_range[1]\n                pvdb[pvname][\"lolim\"] = variable.value_range[0]\n\n            if variable.units is not None:\n                pvdb[pvname][\"unit\"] = variable.units\n\n        elif variable.variable_type == \"array\":\n\n            # assign default PVS\n            pvdb.update(\n                {\n                    f\"{pvname}:NDimensions_RBV\": {\n                        \"type\": \"float\",\n                        \"prec\": variable.precision,\n                        \"value\": variable.value.ndim,\n                    },\n                    f\"{pvname}:Dimensions_RBV\": {\n                        \"type\": \"int\",\n                        \"prec\": variable.precision,\n                        \"count\": variable.value.ndim,\n                        \"value\": variable.value.shape,\n                    },\n                    f\"{pvname}:ArrayData_RBV\": {\n                        \"type\": variable.value_type,\n                        \"prec\": variable.precision,\n                        \"count\": int(np.prod(variable.value.shape)),\n                        \"value\": variable.value.flatten(),\n                    },\n                    f\"{pvname}:ArraySize_RBV\": {\n                        \"type\": \"int\",\n                        \"value\": int(np.prod(variable.value.shape)),\n                    },\n                }\n            )\n\n            child_to_parent_map.update(\n                {\n                    f\"{pvname}:{child}\": variable.name\n                    for child in [\n                        \"NDimensions_RBV\",\n                        \"Dimensions_RBV\",\n                        \"ArraySize_RBV\",\n                        \"ArrayData_RBV\",\n                    ]\n                }\n            )\n\n            if \"units\" in variable.__fields_set__:\n                pvdb[f\"{pvname}:ArrayData_RBV\"][\"unit\"] = variable.units\n\n    return pvdb, child_to_parent_map\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAServer","title":"<code>PVAServer</code>","text":"<p>         Bases: <code>multiprocessing.Process</code></p> <p>Process-based implementation of Channel Access server.</p> <p>Attributes:</p> Name Type Description <code>pva_server</code> <code>P4PServer</code> <p>p4p server instance</p> <code>exit_event</code> <code>multiprocessing.Event</code> <p>Event indicating pvAccess server error and communicating to main</p> <code>shutdown_event</code> <code>multiprocessing.Event</code> <p>Event indicating shutdown</p> <code>_input_variables</code> <code>List[InputVariable]</code> <p>List of input variables</p> <code>_output_variables</code> <code>List[OutputVariable]</code> <p>List of output variables</p> <code>_in_queue</code> <code>multiprocessing.Queue</code> <p>input variable queue</p> <code>_out_queue</code> <code>multiprocessing.Queue</code> <p>output variable update queue</p> <code>_providers</code> <code>dict</code> <p>Dictionary mapping pvname to p4p provider</p> <code>_running_indicator</code> <code>multiprocessing.Value</code> <p>Boolean indicator of running model execution</p> <code>_monitors</code> <code>dict</code> <p>Dictionary of monitor objects for read-only server</p> <code>_cached_values</code> <code>dict</code> <p>Dict for caching values while model executes</p> <code>_pvname_to_varname_map</code> <code>dict</code> <p>Mapping of pvname to variable name</p> <code>_varname_to_pvname_map</code> <code>dict</code> <p>Mapping of variable name to pvame</p> Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>class PVAServer(multiprocessing.Process):\n\"\"\"\n    Process-based implementation of Channel Access server.\n\n    Attributes:\n        pva_server (P4PServer): p4p server instance\n        exit_event (multiprocessing.Event): Event indicating pvAccess server error and communicating to main\n        shutdown_event (multiprocessing.Event): Event indicating shutdown\n        _input_variables (List[InputVariable]): List of input variables\n        _output_variables (List[OutputVariable]): List of output variables\n        _in_queue (multiprocessing.Queue): input variable queue\n        _out_queue (multiprocessing.Queue): output variable update queue\n        _providers (dict): Dictionary mapping pvname to p4p provider\n        _running_indicator (multiprocessing.Value): Boolean indicator of running model execution\n        _monitors (dict): Dictionary of monitor objects for read-only server\n        _cached_values (dict): Dict for caching values while model executes\n        _pvname_to_varname_map (dict): Mapping of pvname to variable name\n        _varname_to_pvname_map (dict): Mapping of variable name to pvame\n\n    \"\"\"\n\n    protocol = \"pva\"\n\n    def __init__(\n        self,\n        input_variables: List[InputVariable],\n        output_variables: List[OutputVariable],\n        epics_config: dict,\n        in_queue: multiprocessing.Queue,\n        out_queue: multiprocessing.Queue,\n        running_indicator: multiprocessing.Value,\n        *args,\n        **kwargs,\n    ) -&gt; None:\n\"\"\"Initialize server process.\n\n        Args:\n            input_variables (Dict[str, InputVariable]): Dictionary mapping pvname to lume-model input variable.\n\n            output_variables (Dict[str, OutputVariable]):Dictionary mapping pvname to lume-model output variable.\n\n            epics_config (dict): Dictionary describing EPICS configuration for model variables\n\n            in_queue (multiprocessing.Queue): Queue for tracking updates to input variables\n\n            out_queue (multiprocessing.Queue): Queue for tracking updates to output variables\n\n            running_indicator (multiprocessing.Value): Boolean indicator indicating running model execution\n\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n        self.pva_server = None\n        self.exit_event = multiprocessing.Event()\n        self.shutdown_event = multiprocessing.Event()\n        self._input_variables = input_variables\n        self._output_variables = output_variables\n        self._epics_config = epics_config\n        self._in_queue = in_queue\n        self._out_queue = out_queue\n        self._providers = {}\n        self._running_indicator = running_indicator\n        # monitors for read only\n        self._monitors = {}\n        self._cached_values = {}\n        self._field_to_parent_map = {}\n\n        # utility maps\n        self._pvname_to_varname_map = {\n            config[\"pvname\"]: var_name for var_name, config in epics_config.items()\n        }\n        self._varname_to_pvname_map = {\n            var_name: config[\"pvname\"] for var_name, config in epics_config.items()\n        }\n\n    def update_pv(self, pvname: str, value: Union[np.ndarray, float]) -&gt; None:\n\"\"\"Adds update to input process variable to the input queue.\n\n        Args:\n            pvname (str): Name of process variable\n\n            value (Union[np.ndarray, float]): Value to set\n\n        \"\"\"\n        # Hack for now to get the pickable value\n        value = value.raw.value\n\n        varname = self._pvname_to_varname_map[pvname]\n        model_variable = self._input_variables[varname]\n\n        # check for already cached variable\n        model_variable = self._cached_values.get(varname, model_variable)\n\n        if model_variable.variable_type == \"image\":\n            model_variable.x_min = value.attrib[\"x_min\"]\n            model_variable.x_max = value.attrib[\"x_max\"]\n            model_variable.y_min = value.attrib[\"y_min\"]\n            model_variable.y_max = value.attrib[\"y_max\"]\n        else:\n            model_variable.value = value\n\n        self._cached_values[varname] = model_variable\n\n        # only update if not running\n        if not self._running_indicator.value:\n            self._in_queue.put({\"protocol\": self.protocol, \"vars\": self._cached_values})\n            self._cached_values = {}\n\n    def _monitor_callback(self, pvname, V) -&gt; None:\n\"\"\"Callback function used for updating read_only process variables.\"\"\"\n        value = V.raw.value\n        varname = self._pvname_to_varname_map[pvname]\n        model_variable = self._input_variables[varname]\n\n        if not model_variable:\n            model_variable = self._output_variables[varname]\n\n        # check for already cached variable\n        model_variable = self._cached_values.get(varname, model_variable)\n\n        if model_variable.variable_type == \"image\":\n            model_variable.x_min = value.attrib[\"x_min\"]\n            model_variable.x_max = value.attrib[\"x_max\"]\n            model_variable.y_min = value.attrib[\"y_min\"]\n            model_variable.y_max = value.attrib[\"y_max\"]\n\n        self._cached_values[varname] = model_variable\n\n        # only update if not running\n        if not self._running_indicator.value:\n            self._in_queue.put({\"protocol\": self.protocol, \"vars\": self._cached_values})\n            self._cached_values = {}\n\n    def _initialize_model(self):\n\"\"\"Initialize model\"\"\"\n\n        rep = {\"protocol\": \"pva\", \"vars\": self._input_variables}\n\n        self._in_queue.put(rep)\n\n    def setup_server(self) -&gt; None:\n\"\"\"Configure and start server.\"\"\"\n\n        self._context = Context()\n\n        # update value with stored defaults\n        for var_name in self._input_variables:\n            if self._epics_config[var_name][\"serve\"]:\n                self._input_variables[var_name].value = self._input_variables[\n                    var_name\n                ].default\n\n            else:\n                if self._context is None:\n                    self._context = Context(\"pva\")\n\n                try:\n                    val = self._context.get(self._varname_to_pvname_map[var_name])\n                    val = val.raw.value\n\n                except:\n                    self.exit_event.set()\n                    raise ValueError(\n                        f\"Unable to connect to {self._varname_to_pvname_map[var_name]}\"\n                    )\n\n                self._input_variables[var_name].value = val\n\n        # update output variable values\n        self._initialize_model()\n        model_outputs = None\n        while not self.shutdown_event.is_set() and model_outputs is None:\n            try:\n                model_outputs = self._out_queue.get(timeout=0.1)\n            except Empty:\n                pass\n\n        if self.shutdown_event.is_set():\n            pass\n\n        # if startup hasn't failed\n        else:\n            model_output_vars = model_outputs.get(\"output_variables\", {})\n            self._output_variables.update(model_output_vars)\n\n            variables = copy.deepcopy(self._input_variables)\n            variables.update(self._output_variables)\n\n            # ignore interrupt in subprocess\n            signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n            logger.info(\"Initializing pvAccess server\")\n\n            # initialize global inputs\n            self._structures = {}\n            self._structure_specs = {}\n            for variable_name, config in self._epics_config.items():\n                if config[\"serve\"]:\n                    fields = config.get(\"fields\")\n                    pvname = config.get(\"pvname\")\n\n                    if fields is not None:\n                        spec = []\n                        structure = {}\n\n                        for field in fields:\n                            # track fields in dict\n                            self._field_to_parent_map[field] = variable_name\n\n                            variable = variables[field]\n\n                            if variable is None:\n                                raise ValueError(\n                                    f\"Field {field} for {variable_name} not found in variable list\"\n                                )\n\n                            if variable.variable_type == \"scalar\":\n                                spec.append((field, \"d\"))\n                                nt = NTScalar(\"d\")\n                                initial = variable.value\n\n                            if variable.variable_type == \"table\":\n                                spec.append((field, \"v\"))\n                                table_rep = ()\n                                for col in variable.columns:\n                                    # here we assume double type in tables...\n                                    table_rep += (col, \"ad\")\n\n                                nt = NTTable(table_rep)\n                                initial = nt.wrap(variable.value)\n\n                            if variable.variable_type == \"array\":\n                                spec.append((field, \"v\"))\n\n                                if variable.value_type == \"str\":\n                                    nt = NTScalar(\"s\")\n                                    initial = variable.value\n\n                                else:\n                                    nd_array = variable.value.view(NTNDArrayData)\n                                    nt = NTNDArray()\n                                    initial = nt.wrap(nd_array)\n\n                            if variable.variable_type == \"image\":\n                                spec.append((field, \"v\"))\n\n                                nd_array = variable.value.view(NTNDArrayData)\n                                nd_array.attrib = {\n                                    \"x_min\": variable.x_min,\n                                    \"y_min\": variable.y_min,\n                                    \"x_max\": variable.x_max,\n                                    \"y_max\": variable.y_max,\n                                }\n\n                                nt = NTNDArray()\n                                initial = nt.wrap(nd_array)\n\n                            structure[field] = initial\n\n                        # assemble pv\n                        self._structures[variable_name] = structure\n                        self._structure_specs[variable_name] = spec\n                        struct_type = Type(id=variable_name, spec=spec)\n                        struct_value = Value(struct_type, structure)\n                        pv = SharedPV(initial=struct_value)\n                        self._providers[pvname] = pv\n\n                    else:\n                        variable = variables[variable_name]\n                        # prepare scalar variable types\n                        if variable.variable_type == \"scalar\":\n                            nt = NTScalar(\"d\")\n                            initial = variable.value\n\n                        # prepare image variable types\n                        elif variable.variable_type == \"image\":\n                            nd_array = variable.value.view(NTNDArrayData)\n                            nd_array.attrib = {\n                                \"x_min\": variable.x_min,\n                                \"y_min\": variable.y_min,\n                                \"x_max\": variable.x_max,\n                                \"y_max\": variable.y_max,\n                            }\n                            nt = NTNDArray()\n                            initial = nd_array\n\n                        elif variable.variable_type == \"table\":\n                            table_rep = ()\n                            for col in variable.columns:\n                                # here we assume double type in tables...\n                                table_rep += (col, \"ad\")\n\n                            nt = NTTable(table_rep)\n                            initial = nt.wrap(variable.value)\n\n                        elif variable.variable_type == \"array\":\n                            if variable.value_type == \"str\":\n                                nt = NTScalar(\"as\")\n                                initial = variable.value\n\n                            else:\n                                nd_array = variable.value.view(NTNDArrayData)\n                                nt = NTNDArray()\n                                initial = nd_array\n\n                        else:\n                            raise ValueError(\n                                \"Unsupported variable type provided: %s\",\n                                variable.variable_type,\n                            )\n\n                        if variable.name in self._input_variables:\n                            handler = PVAccessInputHandler(\n                                pvname=pvname,\n                                is_constant=variable.is_constant,\n                                server=self,\n                            )\n\n                            pv = SharedPV(handler=handler, nt=nt, initial=initial)\n\n                        else:\n                            pv = SharedPV(nt=nt, initial=initial)\n\n                        self._providers[pvname] = pv\n\n                # if not serving pv, set up monitor\n                else:\n                    if variable.name in self._input_variables:\n                        self._monitors[pvname] = self._context.monitor(\n                            pvname, partial(self._monitor_callback, pvname)\n                        )\n\n                    # in this case, externally hosted output variable\n                    else:\n                        self._providers[pvname] = None\n\n            if \"summary\" in self._epics_config:\n                pvname = self._epics_config[\"summary\"].get(\"pvname\")\n                owner = self._epics_config[\"summary\"].get(\"owner\")\n                date_published = self._epics_config[\"summary\"].get(\"date_published\")\n                description = self._epics_config[\"summary\"].get(\"description\")\n                id = self._epics_config[\"summary\"].get(\"id\")\n\n                spec = [\n                    (\"id\", \"s\"),\n                    (\"owner\", \"s\"),\n                    (\"date_published\", \"s\"),\n                    (\"description\", \"s\"),\n                    (\"input_variables\", \"as\"),\n                    (\"output_variables\", \"as\"),\n                ]\n                values = {\n                    \"id\": id,\n                    \"date_published\": date_published,\n                    \"description\": description,\n                    \"owner\": owner,\n                    \"input_variables\": [\n                        self._epics_config[var][\"pvname\"]\n                        for var in self._input_variables\n                    ],\n                    \"output_variables\": [\n                        self._epics_config[var][\"pvname\"]\n                        for var in self._input_variables\n                    ],\n                }\n\n                pv_type = Type(id=\"summary\", spec=spec)\n                value = Value(pv_type, values)\n                pv = SharedPV(initial=value)\n                self._providers[pvname] = pv\n\n            # initialize pva server\n            self.pva_server = P4PServer(providers=[self._providers])\n\n            logger.info(\"pvAccess server started\")\n\n    def update_pvs(\n        self,\n        input_variables: Dict[str, InputVariable],\n        output_variables: Dict[str, OutputVariable],\n    ) -&gt; None:\n\"\"\"Update process variables over pvAccess.\n\n        Args:\n            input_variables (Dict[str, InputVariable]): Dict of lume-epics output variables.\n\n            output_variables (Dict[str, OutputVariable]): Dict of lume-model output variables.\n\n        \"\"\"\n        variables = input_variables\n        variables.update(output_variables)\n\n        for variable in variables.values():\n            parent = self._field_to_parent_map.get(variable.name)\n\n            if variable.name in self._input_variables and variable.is_constant:\n                logger.debug(\"Cannot update constant variable.\")\n\n            else:\n                if variable.variable_type == \"image\":\n                    logger.debug(\n                        \"pvAccess image process variable %s updated.\", variable.name\n                    )\n                    nd_array = variable.value.view(NTNDArrayData)\n\n                    # get dw and dh from model output\n                    nd_array.attrib = {\n                        \"x_min\": variable.x_min,\n                        \"y_min\": variable.y_min,\n                        \"x_max\": variable.x_max,\n                        \"y_max\": variable.y_max,\n                    }\n                    value = nd_array\n\n                elif variable.variable_type == \"array\":\n                    logger.debug(\n                        \"pvAccess array process variable %s updated.\", variable.name\n                    )\n                    if variable.value_type == \"str\":\n                        value = variable.value\n\n                    else:\n                        value = variable.value.view(NTNDArrayData)\n\n                # do not build attribute pvs\n                else:\n                    logger.debug(\n                        \"pvAccess process variable %s updated with value %s.\",\n                        variable.name,\n                        variable.value,\n                    )\n                    value = variable.value\n\n            # update structure or pv\n            if parent:\n                self._structures[parent][variable.name] = value\n                struct_type = Type(id=parent, spec=self._structure_specs[parent])\n                value = Value(struct_type, self._structures[parent])\n                pvname = self._varname_to_pvname_map[parent]\n                output_provider = self._providers[pvname]\n\n            else:\n                pvname = self._varname_to_pvname_map[variable.name]\n                output_provider = self._providers[pvname]\n\n            if output_provider:\n                output_provider.post(value)\n\n            # in this case externally hosted\n            else:\n                try:\n                    self._context.put(pvname, value)\n                except:\n                    self.exit_event.set()\n                    self.shutdown()\n\n    def run(self) -&gt; None:\n\"\"\"Start server process.\"\"\"\n        self.setup_server()\n\n        # mark running\n        while not self.shutdown_event.is_set():\n            try:\n                data = self._out_queue.get_nowait()\n                inputs = data.get(\"input_variables\", {})\n                outputs = data.get(\"output_variables\", {})\n                self.update_pvs(inputs, outputs)\n\n                # check cached values\n                if len(self._cached_values) &gt; 0 and not self._running_indicator.value:\n                    self._in_queue.put(\n                        {\"protocol\": self.protocol, \"vars\": self._cached_values}\n                    )\n\n            except Empty:\n                time.sleep(0.1)\n                logger.debug(\"out queue empty\")\n\n        self._context.close()\n        if self.pva_server is not None:\n            self.pva_server.stop()\n\n        logger.info(\"pvAccess server stopped.\")\n\n    def shutdown(self):\n\"\"\"Safely shutdown the server process.\"\"\"\n        self.shutdown_event.set()\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAServer.__init__","title":"<code>__init__(input_variables, output_variables, epics_config, in_queue, out_queue, running_indicator, *args, **kwargs)</code>","text":"<p>Initialize server process.</p> <p>Parameters:</p> Name Type Description Default <code>input_variables</code> <code>Dict[str, InputVariable]</code> <p>Dictionary mapping pvname to lume-model input variable.</p> required <code>output_variables</code> <code>Dict[str, OutputVariable]</code> <p>Dictionary mapping pvname to lume-model output variable.</p> required <code>epics_config</code> <code>dict</code> <p>Dictionary describing EPICS configuration for model variables</p> required <code>in_queue</code> <code>multiprocessing.Queue</code> <p>Queue for tracking updates to input variables</p> required <code>out_queue</code> <code>multiprocessing.Queue</code> <p>Queue for tracking updates to output variables</p> required <code>running_indicator</code> <code>multiprocessing.Value</code> <p>Boolean indicator indicating running model execution</p> required Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>def __init__(\n    self,\n    input_variables: List[InputVariable],\n    output_variables: List[OutputVariable],\n    epics_config: dict,\n    in_queue: multiprocessing.Queue,\n    out_queue: multiprocessing.Queue,\n    running_indicator: multiprocessing.Value,\n    *args,\n    **kwargs,\n) -&gt; None:\n\"\"\"Initialize server process.\n\n    Args:\n        input_variables (Dict[str, InputVariable]): Dictionary mapping pvname to lume-model input variable.\n\n        output_variables (Dict[str, OutputVariable]):Dictionary mapping pvname to lume-model output variable.\n\n        epics_config (dict): Dictionary describing EPICS configuration for model variables\n\n        in_queue (multiprocessing.Queue): Queue for tracking updates to input variables\n\n        out_queue (multiprocessing.Queue): Queue for tracking updates to output variables\n\n        running_indicator (multiprocessing.Value): Boolean indicator indicating running model execution\n\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.pva_server = None\n    self.exit_event = multiprocessing.Event()\n    self.shutdown_event = multiprocessing.Event()\n    self._input_variables = input_variables\n    self._output_variables = output_variables\n    self._epics_config = epics_config\n    self._in_queue = in_queue\n    self._out_queue = out_queue\n    self._providers = {}\n    self._running_indicator = running_indicator\n    # monitors for read only\n    self._monitors = {}\n    self._cached_values = {}\n    self._field_to_parent_map = {}\n\n    # utility maps\n    self._pvname_to_varname_map = {\n        config[\"pvname\"]: var_name for var_name, config in epics_config.items()\n    }\n    self._varname_to_pvname_map = {\n        var_name: config[\"pvname\"] for var_name, config in epics_config.items()\n    }\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAServer.run","title":"<code>run()</code>","text":"<p>Start server process.</p> Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"Start server process.\"\"\"\n    self.setup_server()\n\n    # mark running\n    while not self.shutdown_event.is_set():\n        try:\n            data = self._out_queue.get_nowait()\n            inputs = data.get(\"input_variables\", {})\n            outputs = data.get(\"output_variables\", {})\n            self.update_pvs(inputs, outputs)\n\n            # check cached values\n            if len(self._cached_values) &gt; 0 and not self._running_indicator.value:\n                self._in_queue.put(\n                    {\"protocol\": self.protocol, \"vars\": self._cached_values}\n                )\n\n        except Empty:\n            time.sleep(0.1)\n            logger.debug(\"out queue empty\")\n\n    self._context.close()\n    if self.pva_server is not None:\n        self.pva_server.stop()\n\n    logger.info(\"pvAccess server stopped.\")\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAServer.setup_server","title":"<code>setup_server()</code>","text":"<p>Configure and start server.</p> Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>def setup_server(self) -&gt; None:\n\"\"\"Configure and start server.\"\"\"\n\n    self._context = Context()\n\n    # update value with stored defaults\n    for var_name in self._input_variables:\n        if self._epics_config[var_name][\"serve\"]:\n            self._input_variables[var_name].value = self._input_variables[\n                var_name\n            ].default\n\n        else:\n            if self._context is None:\n                self._context = Context(\"pva\")\n\n            try:\n                val = self._context.get(self._varname_to_pvname_map[var_name])\n                val = val.raw.value\n\n            except:\n                self.exit_event.set()\n                raise ValueError(\n                    f\"Unable to connect to {self._varname_to_pvname_map[var_name]}\"\n                )\n\n            self._input_variables[var_name].value = val\n\n    # update output variable values\n    self._initialize_model()\n    model_outputs = None\n    while not self.shutdown_event.is_set() and model_outputs is None:\n        try:\n            model_outputs = self._out_queue.get(timeout=0.1)\n        except Empty:\n            pass\n\n    if self.shutdown_event.is_set():\n        pass\n\n    # if startup hasn't failed\n    else:\n        model_output_vars = model_outputs.get(\"output_variables\", {})\n        self._output_variables.update(model_output_vars)\n\n        variables = copy.deepcopy(self._input_variables)\n        variables.update(self._output_variables)\n\n        # ignore interrupt in subprocess\n        signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n        logger.info(\"Initializing pvAccess server\")\n\n        # initialize global inputs\n        self._structures = {}\n        self._structure_specs = {}\n        for variable_name, config in self._epics_config.items():\n            if config[\"serve\"]:\n                fields = config.get(\"fields\")\n                pvname = config.get(\"pvname\")\n\n                if fields is not None:\n                    spec = []\n                    structure = {}\n\n                    for field in fields:\n                        # track fields in dict\n                        self._field_to_parent_map[field] = variable_name\n\n                        variable = variables[field]\n\n                        if variable is None:\n                            raise ValueError(\n                                f\"Field {field} for {variable_name} not found in variable list\"\n                            )\n\n                        if variable.variable_type == \"scalar\":\n                            spec.append((field, \"d\"))\n                            nt = NTScalar(\"d\")\n                            initial = variable.value\n\n                        if variable.variable_type == \"table\":\n                            spec.append((field, \"v\"))\n                            table_rep = ()\n                            for col in variable.columns:\n                                # here we assume double type in tables...\n                                table_rep += (col, \"ad\")\n\n                            nt = NTTable(table_rep)\n                            initial = nt.wrap(variable.value)\n\n                        if variable.variable_type == \"array\":\n                            spec.append((field, \"v\"))\n\n                            if variable.value_type == \"str\":\n                                nt = NTScalar(\"s\")\n                                initial = variable.value\n\n                            else:\n                                nd_array = variable.value.view(NTNDArrayData)\n                                nt = NTNDArray()\n                                initial = nt.wrap(nd_array)\n\n                        if variable.variable_type == \"image\":\n                            spec.append((field, \"v\"))\n\n                            nd_array = variable.value.view(NTNDArrayData)\n                            nd_array.attrib = {\n                                \"x_min\": variable.x_min,\n                                \"y_min\": variable.y_min,\n                                \"x_max\": variable.x_max,\n                                \"y_max\": variable.y_max,\n                            }\n\n                            nt = NTNDArray()\n                            initial = nt.wrap(nd_array)\n\n                        structure[field] = initial\n\n                    # assemble pv\n                    self._structures[variable_name] = structure\n                    self._structure_specs[variable_name] = spec\n                    struct_type = Type(id=variable_name, spec=spec)\n                    struct_value = Value(struct_type, structure)\n                    pv = SharedPV(initial=struct_value)\n                    self._providers[pvname] = pv\n\n                else:\n                    variable = variables[variable_name]\n                    # prepare scalar variable types\n                    if variable.variable_type == \"scalar\":\n                        nt = NTScalar(\"d\")\n                        initial = variable.value\n\n                    # prepare image variable types\n                    elif variable.variable_type == \"image\":\n                        nd_array = variable.value.view(NTNDArrayData)\n                        nd_array.attrib = {\n                            \"x_min\": variable.x_min,\n                            \"y_min\": variable.y_min,\n                            \"x_max\": variable.x_max,\n                            \"y_max\": variable.y_max,\n                        }\n                        nt = NTNDArray()\n                        initial = nd_array\n\n                    elif variable.variable_type == \"table\":\n                        table_rep = ()\n                        for col in variable.columns:\n                            # here we assume double type in tables...\n                            table_rep += (col, \"ad\")\n\n                        nt = NTTable(table_rep)\n                        initial = nt.wrap(variable.value)\n\n                    elif variable.variable_type == \"array\":\n                        if variable.value_type == \"str\":\n                            nt = NTScalar(\"as\")\n                            initial = variable.value\n\n                        else:\n                            nd_array = variable.value.view(NTNDArrayData)\n                            nt = NTNDArray()\n                            initial = nd_array\n\n                    else:\n                        raise ValueError(\n                            \"Unsupported variable type provided: %s\",\n                            variable.variable_type,\n                        )\n\n                    if variable.name in self._input_variables:\n                        handler = PVAccessInputHandler(\n                            pvname=pvname,\n                            is_constant=variable.is_constant,\n                            server=self,\n                        )\n\n                        pv = SharedPV(handler=handler, nt=nt, initial=initial)\n\n                    else:\n                        pv = SharedPV(nt=nt, initial=initial)\n\n                    self._providers[pvname] = pv\n\n            # if not serving pv, set up monitor\n            else:\n                if variable.name in self._input_variables:\n                    self._monitors[pvname] = self._context.monitor(\n                        pvname, partial(self._monitor_callback, pvname)\n                    )\n\n                # in this case, externally hosted output variable\n                else:\n                    self._providers[pvname] = None\n\n        if \"summary\" in self._epics_config:\n            pvname = self._epics_config[\"summary\"].get(\"pvname\")\n            owner = self._epics_config[\"summary\"].get(\"owner\")\n            date_published = self._epics_config[\"summary\"].get(\"date_published\")\n            description = self._epics_config[\"summary\"].get(\"description\")\n            id = self._epics_config[\"summary\"].get(\"id\")\n\n            spec = [\n                (\"id\", \"s\"),\n                (\"owner\", \"s\"),\n                (\"date_published\", \"s\"),\n                (\"description\", \"s\"),\n                (\"input_variables\", \"as\"),\n                (\"output_variables\", \"as\"),\n            ]\n            values = {\n                \"id\": id,\n                \"date_published\": date_published,\n                \"description\": description,\n                \"owner\": owner,\n                \"input_variables\": [\n                    self._epics_config[var][\"pvname\"]\n                    for var in self._input_variables\n                ],\n                \"output_variables\": [\n                    self._epics_config[var][\"pvname\"]\n                    for var in self._input_variables\n                ],\n            }\n\n            pv_type = Type(id=\"summary\", spec=spec)\n            value = Value(pv_type, values)\n            pv = SharedPV(initial=value)\n            self._providers[pvname] = pv\n\n        # initialize pva server\n        self.pva_server = P4PServer(providers=[self._providers])\n\n        logger.info(\"pvAccess server started\")\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAServer.shutdown","title":"<code>shutdown()</code>","text":"<p>Safely shutdown the server process.</p> Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>def shutdown(self):\n\"\"\"Safely shutdown the server process.\"\"\"\n    self.shutdown_event.set()\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAServer.update_pv","title":"<code>update_pv(pvname, value)</code>","text":"<p>Adds update to input process variable to the input queue.</p> <p>Parameters:</p> Name Type Description Default <code>pvname</code> <code>str</code> <p>Name of process variable</p> required <code>value</code> <code>Union[np.ndarray, float]</code> <p>Value to set</p> required Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>def update_pv(self, pvname: str, value: Union[np.ndarray, float]) -&gt; None:\n\"\"\"Adds update to input process variable to the input queue.\n\n    Args:\n        pvname (str): Name of process variable\n\n        value (Union[np.ndarray, float]): Value to set\n\n    \"\"\"\n    # Hack for now to get the pickable value\n    value = value.raw.value\n\n    varname = self._pvname_to_varname_map[pvname]\n    model_variable = self._input_variables[varname]\n\n    # check for already cached variable\n    model_variable = self._cached_values.get(varname, model_variable)\n\n    if model_variable.variable_type == \"image\":\n        model_variable.x_min = value.attrib[\"x_min\"]\n        model_variable.x_max = value.attrib[\"x_max\"]\n        model_variable.y_min = value.attrib[\"y_min\"]\n        model_variable.y_max = value.attrib[\"y_max\"]\n    else:\n        model_variable.value = value\n\n    self._cached_values[varname] = model_variable\n\n    # only update if not running\n    if not self._running_indicator.value:\n        self._in_queue.put({\"protocol\": self.protocol, \"vars\": self._cached_values})\n        self._cached_values = {}\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAServer.update_pvs","title":"<code>update_pvs(input_variables, output_variables)</code>","text":"<p>Update process variables over pvAccess.</p> <p>Parameters:</p> Name Type Description Default <code>input_variables</code> <code>Dict[str, InputVariable]</code> <p>Dict of lume-epics output variables.</p> required <code>output_variables</code> <code>Dict[str, OutputVariable]</code> <p>Dict of lume-model output variables.</p> required Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>def update_pvs(\n    self,\n    input_variables: Dict[str, InputVariable],\n    output_variables: Dict[str, OutputVariable],\n) -&gt; None:\n\"\"\"Update process variables over pvAccess.\n\n    Args:\n        input_variables (Dict[str, InputVariable]): Dict of lume-epics output variables.\n\n        output_variables (Dict[str, OutputVariable]): Dict of lume-model output variables.\n\n    \"\"\"\n    variables = input_variables\n    variables.update(output_variables)\n\n    for variable in variables.values():\n        parent = self._field_to_parent_map.get(variable.name)\n\n        if variable.name in self._input_variables and variable.is_constant:\n            logger.debug(\"Cannot update constant variable.\")\n\n        else:\n            if variable.variable_type == \"image\":\n                logger.debug(\n                    \"pvAccess image process variable %s updated.\", variable.name\n                )\n                nd_array = variable.value.view(NTNDArrayData)\n\n                # get dw and dh from model output\n                nd_array.attrib = {\n                    \"x_min\": variable.x_min,\n                    \"y_min\": variable.y_min,\n                    \"x_max\": variable.x_max,\n                    \"y_max\": variable.y_max,\n                }\n                value = nd_array\n\n            elif variable.variable_type == \"array\":\n                logger.debug(\n                    \"pvAccess array process variable %s updated.\", variable.name\n                )\n                if variable.value_type == \"str\":\n                    value = variable.value\n\n                else:\n                    value = variable.value.view(NTNDArrayData)\n\n            # do not build attribute pvs\n            else:\n                logger.debug(\n                    \"pvAccess process variable %s updated with value %s.\",\n                    variable.name,\n                    variable.value,\n                )\n                value = variable.value\n\n        # update structure or pv\n        if parent:\n            self._structures[parent][variable.name] = value\n            struct_type = Type(id=parent, spec=self._structure_specs[parent])\n            value = Value(struct_type, self._structures[parent])\n            pvname = self._varname_to_pvname_map[parent]\n            output_provider = self._providers[pvname]\n\n        else:\n            pvname = self._varname_to_pvname_map[variable.name]\n            output_provider = self._providers[pvname]\n\n        if output_provider:\n            output_provider.post(value)\n\n        # in this case externally hosted\n        else:\n            try:\n                self._context.put(pvname, value)\n            except:\n                self.exit_event.set()\n                self.shutdown()\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAccessInputHandler","title":"<code>PVAccessInputHandler</code>","text":"<p>Handler object that defines the callbacks to execute on put operations to input process variables.</p> Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>class PVAccessInputHandler:\n\"\"\"\n    Handler object that defines the callbacks to execute on put operations to input\n    process variables.\n    \"\"\"\n\n    def __init__(self, pvname: str, is_constant: bool, server: PVAServer):\n\"\"\"\n        Initialize the handler with prefix and image pv attributes\n\n        Args:\n            pvname (str): The PV being handled\n            is_constant (bool): Indicator of constant variable\n            server (PVAServer): Reference to the server holding this PV\n\n        \"\"\"\n        self.is_constant = is_constant\n        self.pvname = pvname\n        self.server = server\n\n    def put(self, pv: SharedPV, op: ServOpWrap) -&gt; None:\n\"\"\"Updates the global input process variable state, posts the input process\n        variable value change, runs the thread local BaseModel instance\n        using the updated global input process variable states, and posts the model\n        output values to the output process variables.\n\n        Args:\n            pv (SharedPV): Input process variable on which the put operates.\n\n            op (ServOpWrap): Server operation initiated by the put call.\n\n        \"\"\"\n        # update input values and global input process variable state\n        if not self.is_constant and op.value() is not None:\n            pv.post(op.value())\n            self.server.update_pv(pvname=self.pvname, value=op.value())\n        # mark server operation as complete\n        op.done()\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAccessInputHandler.__init__","title":"<code>__init__(pvname, is_constant, server)</code>","text":"<p>Initialize the handler with prefix and image pv attributes</p> <p>Parameters:</p> Name Type Description Default <code>pvname</code> <code>str</code> <p>The PV being handled</p> required <code>is_constant</code> <code>bool</code> <p>Indicator of constant variable</p> required <code>server</code> <code>PVAServer</code> <p>Reference to the server holding this PV</p> required Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>def __init__(self, pvname: str, is_constant: bool, server: PVAServer):\n\"\"\"\n    Initialize the handler with prefix and image pv attributes\n\n    Args:\n        pvname (str): The PV being handled\n        is_constant (bool): Indicator of constant variable\n        server (PVAServer): Reference to the server holding this PV\n\n    \"\"\"\n    self.is_constant = is_constant\n    self.pvname = pvname\n    self.server = server\n</code></pre>"},{"location":"Server/#lume_epics.epics_pva_server.PVAccessInputHandler.put","title":"<code>put(pv, op)</code>","text":"<p>Updates the global input process variable state, posts the input process variable value change, runs the thread local BaseModel instance using the updated global input process variable states, and posts the model output values to the output process variables.</p> <p>Parameters:</p> Name Type Description Default <code>pv</code> <code>SharedPV</code> <p>Input process variable on which the put operates.</p> required <code>op</code> <code>ServOpWrap</code> <p>Server operation initiated by the put call.</p> required Source code in <code>lume_epics/epics_pva_server.py</code> <pre><code>def put(self, pv: SharedPV, op: ServOpWrap) -&gt; None:\n\"\"\"Updates the global input process variable state, posts the input process\n    variable value change, runs the thread local BaseModel instance\n    using the updated global input process variable states, and posts the model\n    output values to the output process variables.\n\n    Args:\n        pv (SharedPV): Input process variable on which the put operates.\n\n        op (ServOpWrap): Server operation initiated by the put call.\n\n    \"\"\"\n    # update input values and global input process variable state\n    if not self.is_constant and op.value() is not None:\n        pv.post(op.value())\n        self.server.update_pv(pvname=self.pvname, value=op.value())\n    # mark server operation as complete\n    op.done()\n</code></pre>"},{"location":"Widgets/","title":"Widgets","text":""},{"location":"Widgets_doc/","title":"Widgets","text":"<p><code>Lume-epics</code> is packaged along with several widgets that can be used alongside a <code>lume-epics</code> controller to interact with the model process variables over EPICS. These widgets have bokeh attributes, which may be embedded into bokeh page layouts during client construction.</p> <p>All widgets accept a <code>lume-epics</code> controller, and a <code>lume-model</code> variable or a list of variables for construction.</p>"},{"location":"Widgets_doc/#control-widgets","title":"Control widgets","text":"<p>These widgets are used for manipulating process variable values.</p>"},{"location":"Widgets_doc/#sliders","title":"Sliders","text":"<p>Sliders are used for setting process variable values along a continuous range. A utility function (<code>build_sliders.py</code>) has been provided that returns a list of slider widgets. The associated bokeh widget for rendering may be accessed on any slider by the <code>.slider</code> attribute.</p> <p>An example implementation, including registered callbacks for continual value syncing with the server is included below:</p> <pre><code>from bokeh.io import curdoc\nfrom bokeh import palettes\nfrom bokeh.layouts import column, row\n\nfrom lume_epics.client.controller import Controller\nfrom lume_model.utils import load_variables\nfrom lume_epics.client.widgets.controls import build_sliders\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\n\n# use example variables packaged with lume-epics\nwith open(\"examples/files/demo_config.yml.yml\", \"r\") as f:\n    input_variables, output_variables = variables_from_yaml(f)\n\nwith open(\"examples/files/epics_config.yml.yml\", \"r\") as f:\n    epics_config = config_from_yaml(f)\n\n# load variables\ninput_variables, output_variables = load_variables(variable_filename)\n\n# set up controller\ncontroller = Controller(epics_config)\n\n# convert ot list for slider use\ninput_variables = list(input_variable.values())\n\n# build sliders\nsliders = build_sliders(input_variables, controller)\n\n# render\ncurdoc().title = \"Demo App\"\ncurdoc().add_root(\n            column([slider.bokeh_slider for slider in sliders])\n        )\n\nfor slider in sliders:\n    curdoc().add_periodic_callback(slider.update, 250)\n</code></pre>"},{"location":"Widgets_doc/#entry-table","title":"Entry table","text":"<p>The entry table is used for single value updates to process variables. Bulk modification can also be submitted using the entry table. The table is composed of labels and entry fields. The entry table is also packaged with a clear button, for clearing the entered values from the fields, and a submit button for sending the values to the process variables.</p> <pre><code>from bokeh.io import curdoc\nfrom bokeh import palettes\nfrom bokeh.layouts import column, row\n\nfrom lume_epics.client.controller import Controller\nfrom lume_model.utils import load_variables\nfrom lume_epics.client.widgets.controls import EntryTable\n\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\n\nwith open(\"examples/files/demo_config.yml.yml\", \"r\") as f:\n    input_variables, output_variables = variables_from_yaml(f)\n\nwith open(\"examples/files/epics_config.yml.yml\", \"r\") as f:\n    epics_config = config_from_yaml(f)\n\n# set up controller\ncontroller = Controller(epics_config)\n\n# conver to list for use with table\ninput_variables = list(input_variable.values())\n\n# build entry table\nentry_table = EntryTable(input_variables, controller)\n\n# render\ncurdoc().title = \"Demo App\"\ncurdoc().add_root(\n            row(entry_table.table, column(entry_table.submit, entry_table.clear))\n        )\n</code></pre>"},{"location":"Widgets_doc/#display-widgets","title":"Display widgets","text":""},{"location":"Widgets_doc/#imageplot","title":"ImagePlot","text":"<p>Image plots are used for displaying image process variables. The image plot requires a manual call of the <code>build_plot</code> function which accepts a bokeh colormap or palette for rendering. The image update callback must be registed in order to sync with the server.</p> <pre><code>from bokeh.io import curdoc\nfrom bokeh import palettes\nfrom bokeh.layouts import column, row\n\nfrom lume_epics.client.controller import Controller\nfrom lume_model.utils import load_variables\nfrom lume_epics.client.widgets.plots import ImagePlot\n\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\n\nwith open(\"examples/files/demo_config.yml.yml\", \"r\") as f:\n    input_variables, output_variables = variables_from_yaml(f)\n\nwith open(\"examples/files/epics_config.yml.yml\", \"r\") as f:\n    epics_config = config_from_yaml(f)\n\n# set up controller\ncontroller = Controller(epics_config)\n\n# select our image output variable to render\nimage_output = [output_variables[\"output1\"]]\n\n# create image plot\nimage_plot = ImagePlot(image_output, controller)\n\npal = palettes.viridis(256)\ncolor_mapper = LinearColorMapper(palette=pal, low=0, high=256)\n\nimage_plot.build_plot(color_mapper=color_mapper)\n\n# render\ncurdoc().title = \"Demo App\"\ncurdoc().add_root(column(image_plot.plot))\n\n# add image update callback\ncurdoc().add_periodic_callback(image_plot.update, 250)\n</code></pre>"},{"location":"Widgets_doc/#striptool","title":"Striptool","text":"<p>The striptool includes a dropdown field for toggling between process variables. The striptool includes a selection toggle and a reset button, which may be rendered along with the plot.</p> <pre><code>from bokeh.io import curdoc\nfrom bokeh import palettes\nfrom bokeh.layouts import column, row\n\nfrom lume_epics.client.controller import Controller\nfrom lume_model.utils import load_variables\nfrom lume_epics.client.widgets.plots import Striptool\n\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\n\nwith open(\"examples/files/demo_config.yml.yml\", \"r\") as f:\n    input_variables, output_variables = variables_from_yaml(f)\n\nwith open(\"examples/files/epics_config.yml.yml\", \"r\") as f:\n    epics_config = config_from_yaml(f)\n\n# set up controller\ncontroller = Controller(epics_config)\n\nstriptool = Striptool([output_variables[\"output2\"], output_variables[\"output3\"]], controller)\n\n# render\ncurdoc().title = \"Demo App\"\ncurdoc().add_root(row(striptool.plot,  striptool.selection, striptool.reset_button))\n\n# add striptool update callback\ncurdoc().add_periodic_callback(striptool.update, 250)\n\n</code></pre>"},{"location":"Widgets_doc/#valuetable","title":"ValueTable","text":"<p>The <code>ValueTable</code> widget is used for displaying process variables and their current values.</p> <pre><code>from bokeh.io import curdoc\nfrom bokeh import palettes\nfrom bokeh.layouts import column, row\n\nfrom lume_epics.client.controller import Controller\nfrom lume_model.utils import load_variables\nfrom lume_epics.client.widgets.table import ValueTable\n\nfrom lume_model.utils import variables_from_yaml\nfrom lume_epics.utils import config_from_yaml\n\nwith open(\"examples/files/demo_config.yml.yml\", \"r\") as f:\n    input_variables, output_variables = variables_from_yaml(f)\n\nwith open(\"examples/files/epics_config.yml.yml\", \"r\") as f:\n    epics_config = config_from_yaml(f)\n\n# set up controller\ncontroller = Controller(epics_config)\n\nvalue_table = ValueTable([output_variables[\"output2\"], output_variables[\"output3\"]], controller)\n\n# render\ncurdoc().title = \"Demo App\"\ncurdoc().add_root(value_table.table)\n\n# add striptool update callback\ncurdoc().add_periodic_callback(value_table.update, 250)\n</code></pre>"}]}